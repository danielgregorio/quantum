[
  {
    "description": "Multi-step data processing pipeline",
    "code": "<q:query connection=\"db\" sql=\"SELECT user_id, SUM(amount) as total_spent FROM orders WHERE created_at >= :date GROUP BY user_id HAVING SUM(amount) > :threshold\" :date=\"'2024-01-01'\" :threshold=\"1000\" />\n<q:set name=\"vip_users\" value=\"{$query_result}\" />\n<q:loop items=\"{vip_users}\" item=\"vip\">\n  <q:query connection=\"db\" sql=\"UPDATE users SET status = :status, vip_since = CURRENT_DATE WHERE id = :id\" :status=\"'VIP'\" :id=\"{vip.user_id}\" />\n</q:loop>\n<q:query connection=\"db\" sql=\"SELECT * FROM users WHERE status = :status\" :status=\"'VIP'\" />\n<div>Updated {$query_result.length} VIP users</div>",
    "expected_behavior": "Identifies high-spending users with HAVING clause, updates their status, and confirms the changes",
    "use_case": "Customer segmentation and automated tier upgrades"
  },
  {
    "description": "Complex JOIN with multiple tables",
    "code": "<q:query connection=\"db\" sql=\"SELECT u.name as user_name, o.id as order_id, o.total_amount, p.name as product_name, oi.quantity FROM users u JOIN orders o ON u.id = o.user_id JOIN order_items oi ON o.id = oi.order_id JOIN products p ON oi.product_id = p.id WHERE u.id = :uid ORDER BY o.created_at DESC\" :uid=\"{user_id}\" />\n<div class=\"detailed-history\">\n  <q:set name=\"current_order\" value=\"null\" />\n  <q:loop items=\"{$query_result}\" item=\"row\">\n    <q:if condition=\"{current_order} != {row.order_id}\">\n      <q:if condition=\"{current_order} != null\">\n        </ul></div>\n      </q:if>\n      <div class=\"order-group\">\n        <h4>Order #{row.order_id} - ${row.total_amount}</h4>\n        <ul>\n      <q:set name=\"current_order\" value=\"{row.order_id}\" />\n    </q:if>\n    <li>{row.product_name} (Qty: {row.quantity})</li>\n  </q:loop>\n  </ul></div>\n</div>",
    "expected_behavior": "Performs 4-table JOIN and groups results by order with nested product display",
    "use_case": "Detailed order history with product breakdown"
  },
  {
    "description": "Conditional query execution based on previous results",
    "code": "<q:query connection=\"db\" sql=\"SELECT id, status FROM orders WHERE id = :oid\" :oid=\"{order_id}\" />\n<q:set name=\"order\" value=\"{$query_result[0]}\" />\n<q:if condition=\"{order.status} == 'pending'\">\n  <q:query connection=\"db\" sql=\"SELECT COUNT(*) as count FROM inventory WHERE product_id IN (SELECT product_id FROM order_items WHERE order_id = :oid) AND quantity >= (SELECT quantity FROM order_items WHERE order_id = :oid)\" :oid=\"{order_id}\" />\n  <q:if condition=\"{$query_result[0].count} > 0\">\n    <q:query connection=\"db\" sql=\"UPDATE orders SET status = :status WHERE id = :oid\" :status=\"'confirmed'\" :oid=\"{order_id}\" />\n    <div>Order confirmed - inventory available</div>\n  </q:if>\n  <q:else>\n    <q:query connection=\"db\" sql=\"UPDATE orders SET status = :status WHERE id = :oid\" :status=\"'backordered'\" :oid=\"{order_id}\" />\n    <div>Order backordered - awaiting stock</div>\n  </q:else>\n</q:if>",
    "expected_behavior": "Checks order status, verifies inventory with subquery, updates status accordingly",
    "use_case": "Order fulfillment workflow with inventory validation"
  },
  {
    "description": "Recursive category tree with aggregation",
    "code": "<q:query connection=\"db\" sql=\"WITH RECURSIVE category_tree AS (SELECT id, name, parent_id, 0 as level FROM categories WHERE parent_id IS NULL UNION ALL SELECT c.id, c.name, c.parent_id, ct.level + 1 FROM categories c JOIN category_tree ct ON c.parent_id = ct.id) SELECT ct.*, COUNT(p.id) as product_count FROM category_tree ct LEFT JOIN products p ON ct.id = p.category_id GROUP BY ct.id, ct.name, ct.parent_id, ct.level ORDER BY ct.level, ct.name\" />\n<div class=\"category-tree\">\n  <q:loop items=\"{$query_result}\" item=\"cat\">\n    <div style=\"margin-left: {cat.level * 20}px\">\n      {cat.name} ({cat.product_count} products)\n    </div>\n  </q:loop>\n</div>",
    "expected_behavior": "Uses recursive CTE to build category hierarchy with product counts at each level",
    "use_case": "Hierarchical category navigation with statistics"
  },
  {
    "description": "Advanced pagination with total count",
    "code": "<q:set name=\"page\" value=\"1\" />\n<q:set name=\"per_page\" value=\"20\" />\n<q:set name=\"offset\" value=\"({page} - 1) * {per_page}\" />\n<q:query connection=\"db\" sql=\"SELECT COUNT(*) as total FROM products WHERE category_id = :cat\" :cat=\"{category_id}\" />\n<q:set name=\"total_items\" value=\"{$query_result[0].total}\" />\n<q:set name=\"total_pages\" value=\"Math.ceil({total_items} / {per_page})\" />\n<q:query connection=\"db\" sql=\"SELECT * FROM products WHERE category_id = :cat ORDER BY name LIMIT :limit OFFSET :offset\" :cat=\"{category_id}\" :limit=\"{per_page}\" :offset=\"{offset}\" />\n<div class=\"pagination-wrapper\">\n  <div class=\"results\">\n    <q:loop items=\"{$query_result}\" item=\"product\">\n      <div>{product.name}</div>\n    </q:loop>\n  </div>\n  <div class=\"pagination-info\">\n    Showing {offset + 1}-{offset + $query_result.length} of {total_items} products\n  </div>\n  <div class=\"pagination-controls\">\n    Page {page} of {total_pages}\n  </div>\n</div>",
    "expected_behavior": "Implements full pagination with total count, page calculation, and range display",
    "use_case": "Professional pagination system with complete navigation info"
  },
  {
    "description": "Transaction simulation with rollback logic",
    "code": "<q:query connection=\"db\" sql=\"SELECT balance FROM accounts WHERE id = :aid\" :aid=\"{from_account}\" />\n<q:set name=\"from_balance\" value=\"{$query_result[0].balance}\" />\n<q:if condition=\"{from_balance} >= {transfer_amount}\">\n  <q:query connection=\"db\" sql=\"UPDATE accounts SET balance = balance - :amount WHERE id = :aid\" :amount=\"{transfer_amount}\" :aid=\"{from_account}\" />\n  <q:query connection=\"db\" sql=\"UPDATE accounts SET balance = balance + :amount WHERE id = :aid\" :amount=\"{transfer_amount}\" :aid=\"{to_account}\" />\n  <q:query connection=\"db\" sql=\"INSERT INTO transactions (from_account, to_account, amount, status) VALUES (:from, :to, :amount, :status) RETURNING id\" :from=\"{from_account}\" :to=\"{to_account}\" :amount=\"{transfer_amount}\" :status=\"'completed'\" />\n  <div>Transfer completed - Transaction ID: {$query_result[0].id}</div>\n</q:if>\n<q:else>\n  <q:query connection=\"db\" sql=\"INSERT INTO transactions (from_account, to_account, amount, status) VALUES (:from, :to, :amount, :status)\" :from=\"{from_account}\" :to=\"{to_account}\" :amount=\"{transfer_amount}\" :status=\"'failed'\" />\n  <div>Transfer failed - Insufficient funds</div>\n</q:else>",
    "expected_behavior": "Validates balance, performs transfer, logs transaction with appropriate status",
    "use_case": "Financial transaction processing with validation"
  },
  {
    "description": "Dynamic query builder with optional filters",
    "code": "<q:set name=\"base_sql\" value=\"'SELECT * FROM products WHERE 1=1'\" />\n<q:set name=\"params\" value=\"{}\" />\n<q:if condition=\"{filter_category} != null\">\n  <q:set name=\"base_sql\" value=\"{base_sql} + ' AND category_id = :category'\" />\n  <q:set name=\"params.category\" value=\"{filter_category}\" />\n</q:if>\n<q:if condition=\"{filter_min_price} != null\">\n  <q:set name=\"base_sql\" value=\"{base_sql} + ' AND price >= :min_price'\" />\n  <q:set name=\"params.min_price\" value=\"{filter_min_price}\" />\n</q:if>\n<q:if condition=\"{filter_max_price} != null\">\n  <q:set name=\"base_sql\" value=\"{base_sql} + ' AND price <= :max_price'\" />\n  <q:set name=\"params.max_price\" value=\"{filter_max_price}\" />\n</q:if>\n<q:set name=\"base_sql\" value=\"{base_sql} + ' ORDER BY created_at DESC'\" />\n<q:query connection=\"db\" sql=\"{base_sql}\" :category=\"{params.category}\" :min_price=\"{params.min_price}\" :max_price=\"{params.max_price}\" />",
    "expected_behavior": "Dynamically builds SQL query string based on which filters are provided",
    "use_case": "Flexible search with optional multiple filters"
  },
  {
    "description": "Batch insert with transaction semantics",
    "code": "<q:set name=\"import_data\" value=\"[{name: 'Product A', price: 10}, {name: 'Product B', price: 20}, {name: 'Product C', price: 30}]\" />\n<q:set name=\"success_count\" value=\"0\" />\n<q:set name=\"error_count\" value=\"0\" />\n<q:loop items=\"{import_data}\" item=\"product\">\n  <q:query connection=\"db\" sql=\"INSERT INTO products (name, price) VALUES (:name, :price)\" :name=\"{product.name}\" :price=\"{product.price}\" />\n  <q:if condition=\"{$query_error} == null\">\n    <q:set name=\"success_count\" value=\"{success_count} + 1\" />\n  </q:if>\n  <q:else>\n    <q:set name=\"error_count\" value=\"{error_count} + 1\" />\n  </q:else>\n</q:loop>\n<div class=\"import-summary\">\n  <div>Successfully imported: {success_count}</div>\n  <div>Failed: {error_count}</div>\n</div>",
    "expected_behavior": "Performs batch insert with error tracking and summary reporting",
    "use_case": "Data import with error handling and reporting"
  },
  {
    "description": "Window function for ranking and analytics",
    "code": "<q:query connection=\"db\" sql=\"SELECT p.*, ROW_NUMBER() OVER (PARTITION BY p.category_id ORDER BY p.sales DESC) as rank_in_category, AVG(p.price) OVER (PARTITION BY p.category_id) as avg_category_price FROM products p\" />\n<div class=\"product-analytics\">\n  <q:loop items=\"{$query_result}\" item=\"product\">\n    <div class=\"product-row\">\n      <span>{product.name}</span>\n      <span>Price: ${product.price} (Avg: ${product.avg_category_price})</span>\n      <span>Rank: #{product.rank_in_category} in category</span>\n    </div>\n  </q:loop>\n</div>",
    "expected_behavior": "Uses window functions to show product ranking within category and category averages",
    "use_case": "Advanced analytics and competitive positioning"
  },
  {
    "description": "Upsert pattern with conflict handling",
    "code": "<q:set name=\"user_email\" value=\"'user@example.com'\" />\n<q:set name=\"user_name\" value=\"'John Doe'\" />\n<q:query connection=\"db\" sql=\"INSERT INTO users (email, name, last_login) VALUES (:email, :name, CURRENT_TIMESTAMP) ON CONFLICT (email) DO UPDATE SET last_login = CURRENT_TIMESTAMP, name = EXCLUDED.name RETURNING id, (xmax = 0) as inserted\" :email=\"{user_email}\" :name=\"{user_name}\" />\n<q:set name=\"result\" value=\"{$query_result[0]}\" />\n<q:if condition=\"{result.inserted}\">\n  <div>New user created with ID: {result.id}</div>\n</q:if>\n<q:else>\n  <div>Existing user updated, ID: {result.id}</div>\n</q:else>",
    "expected_behavior": "Performs upsert (insert or update), returns whether record was new or updated",
    "use_case": "Idempotent user login tracking and profile updates"
  }
]
