[
  {
    "description": "Conditional query execution based on previous results",
    "code": "<q:query datasource=\"app-db\" name=\"orderLookup\">\n  SELECT id, status FROM orders WHERE id = :oid\n  <q:param name=\"oid\" value=\"{order_id}\" type=\"string\" />\n</q:query>\n<q:set name=\"order\" value=\"{orderLookup}\" />\n<q:if condition=\"{order.status} == 'pending'\">\n  <q:query datasource=\"app-db\" name=\"inventoryCheck\">\n    SELECT COUNT(*) as count FROM inventory WHERE product_id IN (SELECT product_id FROM order_items WHERE order_id = :oid) AND quantity >= (SELECT quantity FROM order_items WHERE order_id = :oid)\n    <q:param name=\"oid\" value=\"{order_id}\" type=\"string\" />\n  </q:query>\n  <q:if condition=\"{inventoryCheck.count} > 0\">\n    <q:query datasource=\"app-db\" name=\"confirmOrder\">\n      UPDATE orders SET status = :status WHERE id = :oid\n      <q:param name=\"status\" value=\"confirmed\" type=\"string\" />\n      <q:param name=\"oid\" value=\"{order_id}\" type=\"string\" />\n    </q:query>\n    <div>Order confirmed - inventory available</div>\n  </q:if>\n  <q:else>\n    <q:query datasource=\"app-db\" name=\"backorder\">\n      UPDATE orders SET status = :status WHERE id = :oid\n      <q:param name=\"status\" value=\"backordered\" type=\"string\" />\n      <q:param name=\"oid\" value=\"{order_id}\" type=\"string\" />\n    </q:query>\n    <div>Order backordered - awaiting stock</div>\n  </q:else>\n</q:if>",
    "expected_behavior": "Checks order status, verifies inventory with subquery, updates status accordingly",
    "use_case": "Order fulfillment workflow with inventory validation"
  },
  {
    "description": "Recursive category tree with aggregation",
    "code": "<q:query datasource=\"app-db\" name=\"categoryTree\">\n  WITH RECURSIVE category_tree AS (SELECT id, name, parent_id, 0 as level FROM categories WHERE parent_id IS NULL UNION ALL SELECT c.id, c.name, c.parent_id, ct.level + 1 FROM categories c JOIN category_tree ct ON c.parent_id = ct.id) SELECT ct.*, COUNT(p.id) as product_count FROM category_tree ct LEFT JOIN products p ON ct.id = p.category_id GROUP BY ct.id, ct.name, ct.parent_id, ct.level ORDER BY ct.level, ct.name\n</q:query>\n<div class=\"category-tree\">\n  <q:loop items=\"{categoryTree}\" var=\"cat\">\n    <div style=\"margin-left: {cat.level * 20}px\">\n      {cat.name} ({cat.product_count} products)\n    </div>\n  </q:loop>\n</div>",
    "expected_behavior": "Uses recursive CTE to build category hierarchy with product counts at each level",
    "use_case": "Hierarchical category navigation with statistics"
  },
  {
    "description": "Advanced pagination with total count",
    "code": "<q:set name=\"page\" value=\"1\" />\n<q:set name=\"per_page\" value=\"20\" />\n<q:set name=\"offset\" value=\"({page} - 1) * {per_page}\" />\n<q:query datasource=\"app-db\" name=\"countQuery\">\n  SELECT COUNT(*) as total FROM products WHERE category_id = :cat\n  <q:param name=\"cat\" value=\"{category_id}\" type=\"string\" />\n</q:query>\n<q:set name=\"total_items\" value=\"{countQuery.total}\" />\n<q:set name=\"total_pages\" value=\"Math.ceil({total_items} / {per_page})\" />\n<q:query datasource=\"app-db\" name=\"productList\">\n  SELECT * FROM products WHERE category_id = :cat ORDER BY name LIMIT :limit OFFSET :offset\n  <q:param name=\"cat\" value=\"{category_id}\" type=\"string\" />\n  <q:param name=\"limit\" value=\"{per_page}\" type=\"string\" />\n  <q:param name=\"offset\" value=\"{offset}\" type=\"string\" />\n</q:query>\n<div class=\"pagination-wrapper\">\n  <div class=\"results\">\n    <q:loop items=\"{productList}\" var=\"product\">\n      <div>{product.name}</div>\n    </q:loop>\n  </div>\n  <div class=\"pagination-info\">\n    Showing {offset + 1}-{offset + productList_result.recordCount} of {total_items} products\n  </div>\n  <div class=\"pagination-controls\">\n    Page {page} of {total_pages}\n  </div>\n</div>",
    "expected_behavior": "Implements full pagination with total count, page calculation, and range display",
    "use_case": "Professional pagination system with complete navigation info"
  },
  {
    "description": "Transaction simulation with rollback logic",
    "code": "<q:query datasource=\"app-db\" name=\"balanceCheck\">\n  SELECT balance FROM accounts WHERE id = :aid\n  <q:param name=\"aid\" value=\"{from_account}\" type=\"string\" />\n</q:query>\n<q:set name=\"from_balance\" value=\"{balanceCheck.balance}\" />\n<q:if condition=\"{from_balance} >= {transfer_amount}\">\n  <q:query datasource=\"app-db\" name=\"debit\">\n    UPDATE accounts SET balance = balance - :amount WHERE id = :aid\n    <q:param name=\"amount\" value=\"{transfer_amount}\" type=\"string\" />\n    <q:param name=\"aid\" value=\"{from_account}\" type=\"string\" />\n  </q:query>\n  <q:query datasource=\"app-db\" name=\"credit\">\n    UPDATE accounts SET balance = balance + :amount WHERE id = :aid\n    <q:param name=\"amount\" value=\"{transfer_amount}\" type=\"string\" />\n    <q:param name=\"aid\" value=\"{to_account}\" type=\"string\" />\n  </q:query>\n  <q:query datasource=\"app-db\" name=\"txnLog\">\n    INSERT INTO transactions (from_account, to_account, amount, status) VALUES (:from, :to, :amount, :status) RETURNING id\n    <q:param name=\"from\" value=\"{from_account}\" type=\"string\" />\n    <q:param name=\"to\" value=\"{to_account}\" type=\"string\" />\n    <q:param name=\"amount\" value=\"{transfer_amount}\" type=\"string\" />\n    <q:param name=\"status\" value=\"completed\" type=\"string\" />\n  </q:query>\n  <div>Transfer completed - Transaction ID: {txnLog.id}</div>\n</q:if>\n<q:else>\n  <q:query datasource=\"app-db\" name=\"failedTxnLog\">\n    INSERT INTO transactions (from_account, to_account, amount, status) VALUES (:from, :to, :amount, :status)\n    <q:param name=\"from\" value=\"{from_account}\" type=\"string\" />\n    <q:param name=\"to\" value=\"{to_account}\" type=\"string\" />\n    <q:param name=\"amount\" value=\"{transfer_amount}\" type=\"string\" />\n    <q:param name=\"status\" value=\"failed\" type=\"string\" />\n  </q:query>\n  <div>Transfer failed - Insufficient funds</div>\n</q:else>",
    "expected_behavior": "Validates balance, performs transfer, logs transaction with appropriate status",
    "use_case": "Financial transaction processing with validation"
  },
  {
    "description": "Batch insert with transaction semantics",
    "code": "<q:set name=\"import_data\" value=\"[{name: 'Product A', price: 10}, {name: 'Product B', price: 20}, {name: 'Product C', price: 30}]\" />\n<q:set name=\"success_count\" value=\"0\" />\n<q:set name=\"error_count\" value=\"0\" />\n<q:loop items=\"{import_data}\" var=\"product\">\n  <q:query datasource=\"app-db\" name=\"insertProduct\">\n    INSERT INTO products (name, price) VALUES (:name, :price)\n    <q:param name=\"name\" value=\"{product.name}\" type=\"string\" />\n    <q:param name=\"price\" value=\"{product.price}\" type=\"string\" />\n  </q:query>\n  <q:if condition=\"{insertProduct_result.recordCount} > 0\">\n    <q:set name=\"success_count\" value=\"{success_count} + 1\" />\n  </q:if>\n  <q:else>\n    <q:set name=\"error_count\" value=\"{error_count} + 1\" />\n  </q:else>\n</q:loop>\n<div class=\"import-summary\">\n  <div>Successfully imported: {success_count}</div>\n  <div>Failed: {error_count}</div>\n</div>",
    "expected_behavior": "Performs batch insert with error tracking and summary reporting",
    "use_case": "Data import with error handling and reporting"
  },
  {
    "description": "Window function for ranking and analytics",
    "code": "<q:query datasource=\"app-db\" name=\"productAnalytics\">\n  SELECT p.*, ROW_NUMBER() OVER (PARTITION BY p.category_id ORDER BY p.sales DESC) as rank_in_category, AVG(p.price) OVER (PARTITION BY p.category_id) as avg_category_price FROM products p\n</q:query>\n<div class=\"product-analytics\">\n  <q:loop items=\"{productAnalytics}\" var=\"product\">\n    <div class=\"product-row\">\n      <span>{product.name}</span>\n      <span>Price: ${product.price} (Avg: ${product.avg_category_price})</span>\n      <span>Rank: #{product.rank_in_category} in category</span>\n    </div>\n  </q:loop>\n</div>",
    "expected_behavior": "Uses window functions to show product ranking within category and category averages",
    "use_case": "Advanced analytics and competitive positioning"
  },
  {
    "description": "Upsert pattern with conflict handling",
    "code": "<q:set name=\"user_email\" value=\"'user@example.com'\" />\n<q:set name=\"user_name\" value=\"'John Doe'\" />\n<q:query datasource=\"app-db\" name=\"upsertUser\">\n  INSERT INTO users (email, name, last_login) VALUES (:email, :name, CURRENT_TIMESTAMP) ON CONFLICT (email) DO UPDATE SET last_login = CURRENT_TIMESTAMP, name = EXCLUDED.name RETURNING id, (xmax = 0) as inserted\n  <q:param name=\"email\" value=\"{user_email}\" type=\"string\" />\n  <q:param name=\"name\" value=\"{user_name}\" type=\"string\" />\n</q:query>\n<q:set name=\"result\" value=\"{upsertUser}\" />\n<q:if condition=\"{result.inserted}\">\n  <div>New user created with ID: {result.id}</div>\n</q:if>\n<q:else>\n  <div>Existing user updated, ID: {result.id}</div>\n</q:else>",
    "expected_behavior": "Performs upsert (insert or update), returns whether record was new or updated",
    "use_case": "Idempotent user login tracking and profile updates"
  }
]
