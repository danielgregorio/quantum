"""
Python Code Generator
=====================

Generates Python code from Quantum AST nodes.
"""

import sys
from pathlib import Path
from typing import Optional, List, Set, Any
from dataclasses import dataclass

# Add paths
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from compiler.base_generator import CodeGenerator, GeneratorContext
from compiler.expression_transformer import ExpressionTransformer
from core.ast_nodes import (
    QuantumNode, ComponentNode, ApplicationNode, SetNode, LoopNode,
    IfNode, FunctionNode, HTMLNode, TextNode, QueryNode, ActionNode,
    ImportNode, SlotNode, ComponentCallNode, PythonNode, PyImportNode,
    RedirectNode, FlashNode, DocTypeNode, CommentNode, QueryParamNode
)


class PythonGenerator(CodeGenerator):
    """
    Generates Python code from Quantum AST.

    Produces clean, readable Python that mirrors the Quantum structure
    while being fully native Python.
    """

    def __init__(self):
        super().__init__()
        self.expr_transformer = ExpressionTransformer(target='python')
        self.imports: Set[str] = set()
        self.component_name: str = ''
        self.in_render: bool = False
        self.functions: List[str] = []

    def file_extension(self) -> str:
        return '.py'

    def generate_header(self) -> str:
        """Generate Python file header."""
        lines = [
            '"""',
            'Generated by Quantum Transpiler',
            'Do not edit directly - changes will be overwritten.',
            '"""',
            '',
        ]
        return '\n'.join(lines)

    def generate_footer(self) -> str:
        """Generate file footer."""
        return ''

    def transpile_expression(self, expr: str) -> str:
        """Transpile Quantum expression to Python."""
        return self.expr_transformer.transform(expr)

    # =========================================================================
    # Component & Application
    # =========================================================================

    def visit_ComponentNode(self, node: ComponentNode) -> str:
        """Generate Python class for component."""
        self.component_name = node.name or 'Component'
        self.imports.add('from compiler.python.runtime import Component, escape, bind')

        # Get statements/children - ComponentNode uses 'statements'
        statements = getattr(node, 'statements', None) or getattr(node, 'children', None) or []

        # Emit imports first
        for imp in sorted(self.imports):
            self.emit(imp)
        self.emit_blank()

        # Class definition
        self.emit(f'class {self.component_name}(Component):')
        self.indent()
        self.emit(f'"""Quantum component: {self.component_name}"""')
        self.emit_blank()

        # Render method
        self.emit('def render(self) -> str:')
        self.indent()
        self.in_render = True

        # Initialize HTML builder
        self.emit('_html = []')
        self.emit_blank()

        # Initialize variables from props
        self.emit('# Props')
        self.emit('for _k, _v in self.props.items():')
        self.indent()
        self.emit('locals()[_k] = _v')
        self.dedent()
        self.emit_blank()

        # Process statements
        self.push_scope()
        self.emit('# Component body')
        for child in statements:
            self.visit(child)

        self.pop_scope()
        self.emit_blank()

        # Return joined HTML
        self.emit("return '\\n'.join(_html)")

        self.in_render = False
        self.dedent()
        self.dedent()

        return self.component_name

    def visit_ApplicationNode(self, node: ApplicationNode) -> str:
        """Generate Python code for application."""
        app_name = node.name or 'Application'
        app_type = getattr(node, 'type', 'web')

        self.imports.add('from compiler.python.runtime import Component, escape')

        # Emit imports
        for imp in sorted(self.imports):
            self.emit(imp)
        self.emit_blank()

        self.emit(f'# Application: {app_name} ({app_type})')
        self.emit_blank()

        # Process children (components, routes, etc.)
        for child in node.children or []:
            self.visit(child)

        return app_name

    # =========================================================================
    # State Management
    # =========================================================================

    def visit_SetNode(self, node: SetNode) -> str:
        """Generate variable assignment."""
        name = node.name
        value = getattr(node, 'value', None)
        scope = getattr(node, 'scope', 'local')

        if value is None:
            self.emit(f'{name} = None')
        elif self.is_expression(str(value)):
            expr = self.transpile_expression(str(value))
            self.emit(f'{name} = {expr}')
        elif self.is_literal(str(value)):
            self.emit(f'{name} = {value}')
        else:
            # String value
            self.emit(f'{name} = {repr(value)}')

        self.declare_var(name)
        return name

    # =========================================================================
    # Control Flow
    # =========================================================================

    def visit_LoopNode(self, node: LoopNode) -> str:
        """Generate for loop."""
        # Get loop variable - LoopNode uses var_name
        var = getattr(node, 'var_name', None) or getattr(node, 'var', None) or 'item'
        index_var = getattr(node, 'index_name', None) or getattr(node, 'index', None)

        # Get collection or range - LoopNode uses 'items' for collection
        collection = getattr(node, 'items', None) or getattr(node, 'collection', None)
        from_val = getattr(node, 'from_value', None) or getattr(node, 'from_val', None)
        to_val = getattr(node, 'to_value', None) or getattr(node, 'to_val', None)
        step = getattr(node, 'step_value', None) or getattr(node, 'step', None)

        # Get body - LoopNode uses 'body' not 'children'
        body = getattr(node, 'body', None) or getattr(node, 'children', None) or []

        if collection:
            # Collection-based loop
            coll_expr = self.transpile_expression(str(collection))

            if index_var:
                self.emit(f'for {index_var}, {var} in enumerate({coll_expr}):')
            else:
                self.emit(f'for {var} in {coll_expr}:')
        else:
            # Range-based loop
            start = from_val if from_val is not None else 0
            # Quantum loops are inclusive, Python range is exclusive
            end_expr = f'{to_val} + 1' if to_val is not None else '0'

            if self.is_expression(str(start)):
                start = self.transpile_expression(str(start))
            if to_val and self.is_expression(str(to_val)):
                end_expr = f'({self.transpile_expression(str(to_val))}) + 1'

            if step:
                self.emit(f'for {var} in range({start}, {end_expr}, {step}):')
            else:
                self.emit(f'for {var} in range({start}, {end_expr}):')

        self.indent()
        self.push_scope()
        self.declare_var(var)
        if index_var:
            self.declare_var(index_var)

        # Process body
        for child in body:
            self.visit(child)

        self.pop_scope()
        self.dedent()

        return ''

    def visit_IfNode(self, node: IfNode) -> str:
        """Generate if/elif/else."""
        condition = getattr(node, 'condition', None) or getattr(node, 'test', None)

        if condition:
            cond_expr = self.transpile_expression(str(condition))
            self.emit(f'if {cond_expr}:')
        else:
            self.emit('if True:')

        self.indent()
        self.push_scope()

        # Process if-body (IfNode uses if_body, not children)
        if_body = getattr(node, 'if_body', None) or getattr(node, 'children', None) or []
        has_content = False

        for child in if_body:
            self.visit(child)
            has_content = True

        if not has_content:
            self.emit('pass')

        self.pop_scope()
        self.dedent()

        # Handle elseif blocks
        elseif_blocks = getattr(node, 'elseif_blocks', []) or []
        for elseif in elseif_blocks:
            elseif_cond = elseif.get('condition', '')
            if elseif_cond:
                cond_expr = self.transpile_expression(str(elseif_cond))
                self.emit(f'elif {cond_expr}:')
            else:
                self.emit('elif True:')

            self.indent()
            elseif_body = elseif.get('body', []) or []
            if elseif_body:
                for child in elseif_body:
                    self.visit(child)
            else:
                self.emit('pass')
            self.dedent()

        # Handle else body
        else_body = getattr(node, 'else_body', []) or []
        if else_body:
            self.emit('else:')
            self.indent()
            for child in else_body:
                self.visit(child)
            self.dedent()

        return ''

    # =========================================================================
    # Functions
    # =========================================================================

    def visit_FunctionNode(self, node: FunctionNode) -> str:
        """Generate function definition."""
        name = node.name or 'unnamed_function'
        params = getattr(node, 'params', []) or []

        # Build parameter list
        param_list = []
        for param in params:
            if hasattr(param, 'name'):
                # QuantumParam object
                param_name = param.name
                default = getattr(param, 'default', None)
                if default is not None:
                    param_list.append(f'{param_name}={repr(default)}')
                else:
                    param_list.append(param_name)
            elif isinstance(param, str):
                # String parameter
                param_list.append(param.strip())
            elif isinstance(param, dict):
                # Dict parameter
                param_name = param.get('name', '')
                default = param.get('default')
                if default is not None:
                    param_list.append(f'{param_name}={repr(default)}')
                else:
                    param_list.append(param_name)

        param_str = ', '.join(param_list)
        self.emit(f'def {name}({param_str}):')

        self.indent()
        self.push_scope()

        # Declare parameters
        for param in params:
            if hasattr(param, 'name'):
                self.declare_var(param.name)
            elif isinstance(param, str):
                param_name = param.split('=')[0].strip()
                self.declare_var(param_name)

        # Process body (FunctionNode uses 'body' not 'children')
        body = getattr(node, 'body', None) or getattr(node, 'children', None) or []
        has_return = False
        for child in body:
            child_type = type(child).__name__
            if child_type == 'ReturnNode':
                has_return = True
            self.visit(child)

        # Add implicit return if needed
        if not has_return:
            self.emit('return None')

        self.pop_scope()
        self.dedent()
        self.emit_blank()

        self.functions.append(name)
        return name

    def visit_ReturnNode(self, node) -> str:
        """Generate return statement."""
        value = getattr(node, 'value', None)

        if value:
            expr = self.transpile_expression(str(value))
            self.emit(f'return {expr}')
        else:
            self.emit('return None')

        return ''

    # =========================================================================
    # HTML Rendering
    # =========================================================================

    def visit_HTMLNode(self, node: HTMLNode) -> str:
        """Generate HTML element."""
        tag = node.tag or 'div'
        attributes = getattr(node, 'attributes', {}) or {}
        children = node.children or []

        # Build attributes string
        attr_parts = []
        for key, value in attributes.items():
            if value is None:
                attr_parts.append(key)
            elif self.is_expression(str(value)):
                expr = self.transpile_expression(str(value))
                attr_parts.append(f'{key}="{{escape({expr})}}"')
            else:
                attr_parts.append(f'{key}="{value}"')

        attr_str = ' ' + ' '.join(attr_parts) if attr_parts else ''

        # Self-closing tags
        self_closing = tag.lower() in ('br', 'hr', 'img', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'param', 'source', 'track', 'wbr')

        if self_closing:
            self.emit(f'_html.append(f\'<{tag}{attr_str} />\')')
        elif not children:
            self.emit(f'_html.append(f\'<{tag}{attr_str}></{tag}>\')')
        else:
            self.emit(f'_html.append(f\'<{tag}{attr_str}>\')')

            # Process children
            for child in children:
                self.visit(child)

            self.emit(f"_html.append('</{tag}>')")

        return ''

    def visit_TextNode(self, node: TextNode) -> str:
        """Generate text content."""
        content = getattr(node, 'content', '') or getattr(node, 'text', '') or ''

        if not content.strip():
            return ''

        # Check for databinding
        if '{' in content and '}' in content:
            # Complex expression - use bind()
            self.emit(f"_html.append(bind({repr(content)}, locals()))")
        else:
            # Plain text
            self.emit(f"_html.append({repr(content)})")

        return ''

    def visit_DocTypeNode(self, node: DocTypeNode) -> str:
        """Generate DOCTYPE."""
        self.emit("_html.append('<!DOCTYPE html>')")
        return ''

    def visit_CommentNode(self, node: CommentNode) -> str:
        """Generate HTML comment."""
        content = getattr(node, 'content', '') or getattr(node, 'text', '') or ''
        self.emit(f"_html.append('<!-- {content} -->')")
        return ''

    # =========================================================================
    # Database
    # =========================================================================

    def visit_QueryNode(self, node: QueryNode) -> str:
        """Generate database query."""
        name = node.name or 'result'
        datasource = getattr(node, 'datasource', 'default')

        # Get SQL from content or children
        sql_parts = []
        params = []

        # Check for raw SQL content
        sql_content = getattr(node, 'sql', None) or getattr(node, 'content', None)
        if sql_content:
            sql_parts.append(sql_content.strip())

        # Check children for params and additional SQL
        for child in node.children or []:
            child_type = type(child).__name__
            if child_type == 'QueryParamNode':
                value = getattr(child, 'value', None)
                if value:
                    params.append(self.transpile_expression(str(value)))
                    sql_parts.append('?')
            elif child_type == 'TextNode':
                text = getattr(child, 'content', '') or getattr(child, 'text', '')
                if text.strip():
                    sql_parts.append(text.strip())

        sql = ' '.join(sql_parts).strip()

        # Clean up SQL
        sql = ' '.join(sql.split())  # Normalize whitespace

        self.imports.add('from compiler.python.runtime import Database')

        self.emit(f'# Query: {name}')
        self.emit(f'_db = Database.get_connection({repr(datasource)})')

        if params:
            self.emit(f'{name} = _db.execute({repr(sql)}, [{", ".join(params)}]).fetchall()')
        else:
            self.emit(f'{name} = _db.execute({repr(sql)}).fetchall()')

        self.declare_var(name)
        return name

    def visit_QueryParamNode(self, node: QueryParamNode) -> str:
        """Query params are handled in visit_QueryNode."""
        return ''

    # =========================================================================
    # Actions & Redirects
    # =========================================================================

    def visit_ActionNode(self, node: ActionNode) -> str:
        """Generate action handler."""
        name = getattr(node, 'name', 'action')
        method = getattr(node, 'method', 'POST')

        self.imports.add('from compiler.python.runtime import request, redirect, flash')

        self.emit(f'# Action: {name}')
        self.emit(f'def action_{name}():')
        self.indent()
        self.emit(f'"""Handle {method} action"""')

        self.push_scope()

        for child in node.children or []:
            self.visit(child)

        self.pop_scope()
        self.dedent()
        self.emit_blank()

        return f'action_{name}'

    def visit_RedirectNode(self, node: RedirectNode) -> str:
        """Generate redirect."""
        url = getattr(node, 'url', '/') or getattr(node, 'to', '/')
        status = getattr(node, 'status', 302) or getattr(node, 'code', 302)

        self.imports.add('from compiler.python.runtime import redirect')

        if self.is_expression(str(url)):
            url_expr = self.transpile_expression(str(url))
            self.emit(f'return redirect({url_expr}, code={status})')
        else:
            self.emit(f'return redirect({repr(url)}, code={status})')

        return ''

    def visit_FlashNode(self, node: FlashNode) -> str:
        """Generate flash message."""
        message = getattr(node, 'message', '')
        category = getattr(node, 'category', 'info') or getattr(node, 'type', 'info')

        self.imports.add('from compiler.python.runtime import flash')

        if self.is_expression(str(message)):
            msg_expr = self.transpile_expression(str(message))
            self.emit(f'flash({msg_expr}, {repr(category)})')
        else:
            self.emit(f'flash({repr(message)}, {repr(category)})')

        return ''

    # =========================================================================
    # Imports & Python Integration
    # =========================================================================

    def visit_ImportNode(self, node: ImportNode) -> str:
        """Generate component import."""
        name = getattr(node, 'name', None)
        path = getattr(node, 'path', None) or getattr(node, 'from', None)

        if path and name:
            # Convert path to Python import
            module_path = path.replace('/', '.').replace('.q', '')
            self.imports.add(f'from {module_path} import {name}')

        return ''

    def visit_PyImportNode(self, node: PyImportNode) -> str:
        """Generate Python import."""
        module = getattr(node, 'module', '')
        names = getattr(node, 'names', '') or getattr(node, 'import', '')
        alias = getattr(node, 'as', None) or getattr(node, 'alias', None)

        if names:
            if isinstance(names, str):
                names = names.replace(' ', '')
            self.imports.add(f'from {module} import {names}')
        elif alias:
            self.imports.add(f'import {module} as {alias}')
        else:
            self.imports.add(f'import {module}')

        return ''

    def visit_PythonNode(self, node: PythonNode) -> str:
        """Generate inline Python code."""
        code = getattr(node, 'code', '') or getattr(node, 'content', '')

        if code:
            # Emit raw Python code
            for line in code.strip().split('\n'):
                self.emit(line)

        return ''

    # =========================================================================
    # Component Calls
    # =========================================================================

    def visit_ComponentCallNode(self, node: ComponentCallNode) -> str:
        """Generate component instantiation."""
        name = getattr(node, 'name', 'Component')
        props = getattr(node, 'props', {}) or getattr(node, 'attributes', {}) or {}

        # Build props
        prop_parts = []
        for key, value in props.items():
            if self.is_expression(str(value)):
                expr = self.transpile_expression(str(value))
                prop_parts.append(f'{key}={expr}')
            else:
                prop_parts.append(f'{key}={repr(value)}')

        props_str = ', '.join(prop_parts)

        if self.in_render:
            self.emit(f'_html.append({name}({props_str}).render())')
        else:
            self.emit(f'{name}({props_str})')

        return ''

    def visit_SlotNode(self, node: SlotNode) -> str:
        """Generate slot placeholder."""
        name = getattr(node, 'name', 'default')

        self.emit(f"# Slot: {name}")
        self.emit(f"if '{name}' in self.props.get('_slots', {{}}):")
        self.indent()
        self.emit(f"_html.append(self.props['_slots']['{name}'])")
        self.dedent()

        # Default content
        if node.children:
            self.emit('else:')
            self.indent()
            for child in node.children:
                self.visit(child)
            self.dedent()

        return ''

    # =========================================================================
    # Data Nodes (Phase 2)
    # =========================================================================

    def visit_DataNode(self, node) -> str:
        """Generate data import code."""
        name = getattr(node, 'name', 'data')
        source = getattr(node, 'source', '')
        data_type = getattr(node, 'data_type', None) or getattr(node, 'type', 'json')

        self.imports.add('from compiler.python.runtime import load_data')

        source_expr = self.transpile_expression(str(source)) if self.is_expression(str(source)) else repr(source)

        self.emit(f'# Data import: {name}')
        self.emit(f'{name} = load_data({source_expr}, type={repr(data_type)})')
        self.declare_var(name)

        return name

    def visit_InvokeNode(self, node) -> str:
        """Generate HTTP/service invocation."""
        name = getattr(node, 'name', 'result')
        url = getattr(node, 'url', None)
        method = getattr(node, 'method', 'GET')
        function = getattr(node, 'function', None)
        component = getattr(node, 'component', None)

        self.imports.add('from compiler.python.runtime import invoke')

        self.emit(f'# Invoke: {name}')

        if function:
            # Local function call
            func_expr = self.transpile_expression(str(function)) if self.is_expression(str(function)) else function
            self.emit(f'{name} = {func_expr}()')
        elif component:
            # Component instantiation
            comp_expr = self.transpile_expression(str(component)) if self.is_expression(str(component)) else component
            self.emit(f'{name} = {comp_expr}().render()')
        elif url:
            # HTTP request
            url_expr = self.transpile_expression(str(url)) if self.is_expression(str(url)) else repr(url)

            # Build headers and body from children
            headers = {}
            body = None
            for child in getattr(node, 'children', []) or []:
                child_type = type(child).__name__
                if child_type == 'InvokeHeaderNode':
                    headers[getattr(child, 'name', '')] = getattr(child, 'value', '')
                elif child_type == 'InvokeBodyNode':
                    body = getattr(child, 'content', None)

            headers_str = repr(headers) if headers else '{}'
            body_str = self.transpile_expression(str(body)) if body and self.is_expression(str(body)) else repr(body) if body else 'None'

            self.emit(f'{name} = invoke({url_expr}, method={repr(method)}, headers={headers_str}, body={body_str})')
        else:
            self.emit(f'{name} = None  # No target specified')

        self.declare_var(name)
        return name

    def visit_FileNode(self, node) -> str:
        """Generate file operation code."""
        action = getattr(node, 'action', 'upload')
        file_var = getattr(node, 'file', '')
        destination = getattr(node, 'destination', './uploads/')
        result_var = getattr(node, 'result', None) or getattr(node, 'name', 'file_result')

        self.imports.add('from compiler.python.runtime import handle_file')

        file_expr = self.transpile_expression(str(file_var)) if self.is_expression(str(file_var)) else file_var
        dest_expr = self.transpile_expression(str(destination)) if self.is_expression(str(destination)) else repr(destination)

        self.emit(f'# File operation: {action}')
        self.emit(f'{result_var} = handle_file({file_expr}, action={repr(action)}, destination={dest_expr})')
        self.declare_var(result_var)

        return result_var

    def visit_MailNode(self, node) -> str:
        """Generate email sending code."""
        to = getattr(node, 'to', '')
        from_addr = getattr(node, 'from_', '') or getattr(node, 'sender', '')
        subject = getattr(node, 'subject', '')
        body_content = None

        # Get body from children
        for child in getattr(node, 'children', []) or []:
            if hasattr(child, 'content'):
                body_content = child.content
                break
            elif hasattr(child, 'text'):
                body_content = child.text
                break

        self.imports.add('from compiler.python.runtime import send_mail')

        to_expr = self.transpile_expression(str(to)) if self.is_expression(str(to)) else repr(to)
        from_expr = self.transpile_expression(str(from_addr)) if self.is_expression(str(from_addr)) else repr(from_addr)
        subject_expr = self.transpile_expression(str(subject)) if self.is_expression(str(subject)) else repr(subject)
        body_expr = self.transpile_expression(str(body_content)) if body_content and self.is_expression(str(body_content)) else repr(body_content or '')

        self.emit(f'# Send email')
        self.emit(f'send_mail(to={to_expr}, from_addr={from_expr}, subject={subject_expr}, body={body_expr})')

        return ''

    # =========================================================================
    # Async Nodes (Phase 3)
    # =========================================================================

    def visit_JobNode(self, node) -> str:
        """Generate job queue code."""
        name = getattr(node, 'name', 'job')
        queue = getattr(node, 'queue', 'default')
        action = getattr(node, 'action', 'define')
        priority = getattr(node, 'priority', 0)
        delay = getattr(node, 'delay', None)

        self.imports.add('from compiler.python.runtime import JobQueue')

        self.emit(f'# Job: {name}')

        if action == 'define':
            self.emit(f'@JobQueue.task(queue={repr(queue)}, priority={priority})')
            self.emit(f'def job_{name}(**params):')
            self.indent()
            self.emit('"""Job task"""')
            self.push_scope()
            for child in getattr(node, 'children', []) or []:
                self.visit(child)
            self.pop_scope()
            self.dedent()
            self.emit_blank()
        elif action == 'dispatch':
            delay_str = f', delay={repr(delay)}' if delay else ''
            self.emit(f'JobQueue.dispatch({repr(name)}{delay_str})')
        elif action == 'cancel':
            self.emit(f'JobQueue.cancel({repr(name)})')

        return f'job_{name}'

    def visit_ScheduleNode(self, node) -> str:
        """Generate scheduled task code."""
        name = getattr(node, 'name', 'task')
        interval = getattr(node, 'interval', None)
        cron = getattr(node, 'cron', None)
        at = getattr(node, 'at', None)
        enabled = getattr(node, 'enabled', True)

        self.imports.add('from compiler.python.runtime import Scheduler')

        self.emit(f'# Scheduled task: {name}')

        schedule_args = []
        if interval:
            schedule_args.append(f'interval={repr(interval)}')
        elif cron:
            schedule_args.append(f'cron={repr(cron)}')
        elif at:
            schedule_args.append(f'at={repr(at)}')

        schedule_args.append(f'enabled={enabled}')
        args_str = ', '.join(schedule_args)

        self.emit(f'@Scheduler.schedule({args_str})')
        self.emit(f'def scheduled_{name}():')
        self.indent()
        self.emit(f'"""Scheduled task: {name}"""')
        self.push_scope()
        for child in getattr(node, 'children', []) or []:
            self.visit(child)
        self.pop_scope()
        self.dedent()
        self.emit_blank()

        return f'scheduled_{name}'

    def visit_ThreadNode(self, node) -> str:
        """Generate async thread code."""
        name = getattr(node, 'name', 'thread')
        action = getattr(node, 'action', 'run')
        priority = getattr(node, 'priority', 'normal')
        timeout = getattr(node, 'timeout', None)
        on_complete = getattr(node, 'on_complete', None) or getattr(node, 'onComplete', None)

        self.imports.add('from compiler.python.runtime import AsyncThread')

        self.emit(f'# Thread: {name}')

        if action == 'run':
            timeout_str = f', timeout={repr(timeout)}' if timeout else ''
            callback_str = f', on_complete={on_complete}' if on_complete else ''

            self.emit(f'def thread_{name}_work():')
            self.indent()
            self.emit('"""Thread work function"""')
            self.push_scope()
            for child in getattr(node, 'children', []) or []:
                self.visit(child)
            self.pop_scope()
            self.dedent()
            self.emit_blank()

            self.emit(f'thread_{name} = AsyncThread({repr(name)}, thread_{name}_work{timeout_str}{callback_str})')
            self.emit(f'thread_{name}.start()')
        elif action == 'join':
            self.emit(f'thread_{name}.join()')
        elif action == 'terminate':
            self.emit(f'thread_{name}.terminate()')

        return f'thread_{name}'

    def visit_ParallelNode(self, node) -> str:
        """Generate parallel execution code."""
        name = getattr(node, 'name', 'parallel')
        max_workers = getattr(node, 'max_workers', None) or getattr(node, 'maxWorkers', 4)

        self.imports.add('from compiler.python.runtime import parallel_execute')

        self.emit(f'# Parallel execution: {name}')
        self.emit(f'def parallel_{name}_tasks():')
        self.indent()
        self.emit('tasks = []')

        # Collect child tasks
        for idx, child in enumerate(getattr(node, 'children', []) or []):
            child_type = type(child).__name__
            if child_type == 'ThreadNode' or child_type == 'TaskNode':
                self.emit(f'def _task_{idx}():')
                self.indent()
                self.visit(child)
                self.dedent()
                self.emit(f'tasks.append(_task_{idx})')
            else:
                self.visit(child)

        self.emit(f'return parallel_execute(tasks, max_workers={max_workers})')
        self.dedent()
        self.emit_blank()
        self.emit(f'{name}_results = parallel_{name}_tasks()')
        self.declare_var(f'{name}_results')

        return name

    # =========================================================================
    # Comments
    # =========================================================================

    def emit_comment(self, comment: str):
        """Emit Python comment."""
        self.emit(f'# {comment}')
