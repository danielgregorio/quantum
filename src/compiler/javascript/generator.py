"""
JavaScript Code Generator
=========================

Generates JavaScript code from Quantum AST nodes.
"""

import sys
from pathlib import Path
from typing import Optional, List, Set

# Add paths
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from compiler.base_generator import CodeGenerator
from compiler.expression_transformer import ExpressionTransformer
from core.ast_nodes import (
    QuantumNode, ComponentNode, ApplicationNode, SetNode, LoopNode,
    IfNode, FunctionNode, HTMLNode, TextNode, QueryNode, ActionNode,
    ImportNode, SlotNode, ComponentCallNode, PythonNode, PyImportNode,
    RedirectNode, FlashNode, DocTypeNode, CommentNode
)


class JavaScriptGenerator(CodeGenerator):
    """
    Generates JavaScript code from Quantum AST.

    Produces clean ES6+ JavaScript with module exports.
    """

    def __init__(self):
        super().__init__()
        self.expr_transformer = ExpressionTransformer(target='javascript')
        self.imports: Set[str] = set()
        self.component_name: str = ''
        self.in_render: bool = False
        self.indent_str = "  "  # 2 spaces for JS

    def file_extension(self) -> str:
        return '.js'

    def generate_header(self) -> str:
        """Generate JavaScript file header."""
        lines = [
            '/**',
            ' * Generated by Quantum Transpiler',
            ' * Do not edit directly - changes will be overwritten.',
            ' */',
            '',
            "import { Component, escape, bind, range } from 'quantum-runtime';",
            '',
        ]
        return '\n'.join(lines)

    def generate_footer(self) -> str:
        """Generate file footer with exports."""
        if self.component_name:
            return f'\nexport default {self.component_name};\n'
        return ''

    def transpile_expression(self, expr: str) -> str:
        """Transpile Quantum expression to JavaScript."""
        return self.expr_transformer.transform(expr)

    # =========================================================================
    # Component & Application
    # =========================================================================

    def visit_ComponentNode(self, node: ComponentNode) -> str:
        """Generate JavaScript class for component."""
        self.component_name = node.name or 'Component'

        # Get statements
        statements = getattr(node, 'statements', None) or getattr(node, 'children', None) or []

        # Class definition
        self.emit(f'class {self.component_name} extends Component {{')
        self.indent()

        # Constructor
        self.emit('constructor(props = {}) {')
        self.indent()
        self.emit('super(props);')
        self.dedent()
        self.emit('}')
        self.emit_blank()

        # Render method
        self.emit('render() {')
        self.indent()
        self.in_render = True

        # Initialize
        self.emit('let _html = [];')
        self.emit('const { ...props } = this.props;')
        self.emit_blank()

        # Process statements
        self.push_scope()
        for child in statements:
            self.visit(child)
        self.pop_scope()

        self.emit_blank()
        self.emit("return _html.join('\\n');")

        self.in_render = False
        self.dedent()
        self.emit('}')

        self.dedent()
        self.emit('}')

        return self.component_name

    # =========================================================================
    # State Management
    # =========================================================================

    def visit_SetNode(self, node: SetNode) -> str:
        """Generate variable assignment."""
        name = node.name
        value = getattr(node, 'value', None)

        # Determine if let or const
        keyword = 'let' if not self.is_declared(name) else ''

        if value is None:
            if keyword:
                self.emit(f'{keyword} {name} = null;')
            else:
                self.emit(f'{name} = null;')
        elif self.is_expression(str(value)):
            expr = self.transpile_expression(str(value))
            if keyword:
                self.emit(f'{keyword} {name} = {expr};')
            else:
                self.emit(f'{name} = {expr};')
        elif self.is_literal(str(value)):
            if keyword:
                self.emit(f'{keyword} {name} = {value};')
            else:
                self.emit(f'{name} = {value};')
        else:
            # String value
            escaped = str(value).replace("'", "\\'")
            if keyword:
                self.emit(f"{keyword} {name} = '{escaped}';")
            else:
                self.emit(f"{name} = '{escaped}';")

        self.declare_var(name)
        return name

    # =========================================================================
    # Control Flow
    # =========================================================================

    def visit_LoopNode(self, node: LoopNode) -> str:
        """Generate for loop."""
        var = getattr(node, 'var_name', None) or getattr(node, 'var', None) or 'item'
        index_var = getattr(node, 'index_name', None) or getattr(node, 'index', None)
        collection = getattr(node, 'items', None) or getattr(node, 'collection', None)
        from_val = getattr(node, 'from_value', None) or getattr(node, 'from_val', None)
        to_val = getattr(node, 'to_value', None) or getattr(node, 'to_val', None)
        step = getattr(node, 'step_value', None) or getattr(node, 'step', None) or 1
        body = getattr(node, 'body', None) or getattr(node, 'children', None) or []

        if collection:
            # Collection-based loop
            coll_expr = self.transpile_expression(str(collection))

            if index_var:
                self.emit(f'{coll_expr}.forEach(({var}, {index_var}) => {{')
            else:
                self.emit(f'for (const {var} of {coll_expr}) {{')
        else:
            # Range-based loop (inclusive end)
            start = from_val if from_val is not None else 0
            end = to_val if to_val is not None else 0

            if self.is_expression(str(start)):
                start = self.transpile_expression(str(start))
            if self.is_expression(str(end)):
                end = self.transpile_expression(str(end))

            self.emit(f'for (let {var} = {start}; {var} <= {end}; {var} += {step}) {{')

        self.indent()
        self.push_scope()
        self.declare_var(var)
        if index_var:
            self.declare_var(index_var)

        for child in body:
            self.visit(child)

        self.pop_scope()
        self.dedent()

        if collection and index_var:
            self.emit('});')
        else:
            self.emit('}')

        return ''

    def visit_IfNode(self, node: IfNode) -> str:
        """Generate if/else if/else."""
        condition = getattr(node, 'condition', None) or getattr(node, 'test', None)

        if condition:
            cond_expr = self.transpile_expression(str(condition))
            self.emit(f'if ({cond_expr}) {{')
        else:
            self.emit('if (true) {')

        self.indent()
        self.push_scope()

        # Process if-body
        has_content = False
        else_children = []
        elseif_children = []

        for child in getattr(node, 'children', []) or []:
            child_type = type(child).__name__

            if child_type == 'ElseNode' or (hasattr(child, 'tag') and child.tag == 'q:else'):
                else_children = getattr(child, 'children', []) or []
            elif child_type == 'ElseIfNode' or (hasattr(child, 'tag') and child.tag == 'q:elseif'):
                elseif_children.append(child)
            else:
                self.visit(child)
                has_content = True

        self.pop_scope()
        self.dedent()
        self.emit('}')

        # Handle else if
        for elseif in elseif_children:
            elseif_cond = getattr(elseif, 'condition', None) or getattr(elseif, 'test', None)
            if elseif_cond:
                cond_expr = self.transpile_expression(str(elseif_cond))
                self.emit(f'else if ({cond_expr}) {{')
            else:
                self.emit('else if (true) {')

            self.indent()
            for child in getattr(elseif, 'children', []) or []:
                self.visit(child)
            self.dedent()
            self.emit('}')

        # Handle else
        if else_children:
            self.emit('else {')
            self.indent()
            for child in else_children:
                self.visit(child)
            self.dedent()
            self.emit('}')

        return ''

    # =========================================================================
    # Functions
    # =========================================================================

    def visit_FunctionNode(self, node: FunctionNode) -> str:
        """Generate function definition."""
        name = node.name or 'anonymousFunction'
        params = getattr(node, 'params', '') or ''

        if isinstance(params, str):
            param_list = [p.strip() for p in params.split(',') if p.strip()]
        else:
            param_list = list(params) if params else []

        param_str = ', '.join(param_list)
        self.emit(f'function {name}({param_str}) {{')

        self.indent()
        self.push_scope()

        for param in param_list:
            param_name = param.split('=')[0].strip()
            self.declare_var(param_name)

        for child in getattr(node, 'children', []) or []:
            self.visit(child)

        self.pop_scope()
        self.dedent()
        self.emit('}')
        self.emit_blank()

        return name

    def visit_ReturnNode(self, node) -> str:
        """Generate return statement."""
        value = getattr(node, 'value', None)

        if value:
            expr = self.transpile_expression(str(value))
            self.emit(f'return {expr};')
        else:
            self.emit('return;')

        return ''

    # =========================================================================
    # HTML Rendering
    # =========================================================================

    def visit_HTMLNode(self, node: HTMLNode) -> str:
        """Generate HTML element."""
        tag = node.tag or 'div'
        attributes = getattr(node, 'attributes', {}) or {}
        children = node.children or []

        # Build attributes
        attr_parts = []
        for key, value in attributes.items():
            if value is None:
                attr_parts.append(key)
            elif self.is_expression(str(value)):
                expr = self.transpile_expression(str(value))
                attr_parts.append(f'{key}="${{escape({expr})}}"')
            else:
                attr_parts.append(f'{key}="{value}"')

        attr_str = ' ' + ' '.join(attr_parts) if attr_parts else ''

        # Self-closing tags
        self_closing = tag.lower() in ('br', 'hr', 'img', 'input', 'meta', 'link')

        if self_closing:
            self.emit(f'_html.push(`<{tag}{attr_str} />`);')
        elif not children:
            self.emit(f'_html.push(`<{tag}{attr_str}></{tag}>`);')
        else:
            self.emit(f'_html.push(`<{tag}{attr_str}>`);')

            for child in children:
                self.visit(child)

            self.emit(f"_html.push('</{tag}>');")

        return ''

    def visit_TextNode(self, node: TextNode) -> str:
        """Generate text content."""
        content = getattr(node, 'content', '') or getattr(node, 'text', '') or ''

        if not content.strip():
            return ''

        # Handle databinding with template literals
        if '{' in content and '}' in content:
            # Convert {expr} to ${expr}
            import re
            js_template = re.sub(r'\{([^}]+)\}', r'${\1}', content)
            self.emit(f'_html.push(`{js_template}`);')
        else:
            escaped = content.replace('`', '\\`')
            self.emit(f'_html.push(`{escaped}`);')

        return ''

    def visit_DocTypeNode(self, node: DocTypeNode) -> str:
        """Generate DOCTYPE."""
        self.emit("_html.push('<!DOCTYPE html>');")
        return ''

    def visit_CommentNode(self, node: CommentNode) -> str:
        """Generate HTML comment."""
        content = getattr(node, 'content', '') or getattr(node, 'text', '') or ''
        self.emit(f"_html.push('<!-- {content} -->');")
        return ''

    # =========================================================================
    # Actions & Redirects
    # =========================================================================

    def visit_RedirectNode(self, node: RedirectNode) -> str:
        """Generate redirect."""
        url = getattr(node, 'url', '/') or getattr(node, 'to', '/')

        if self.is_expression(str(url)):
            url_expr = self.transpile_expression(str(url))
            self.emit(f'window.location.href = {url_expr};')
        else:
            self.emit(f"window.location.href = '{url}';")

        return ''

    def visit_FlashNode(self, node: FlashNode) -> str:
        """Generate flash message."""
        message = getattr(node, 'message', '')
        category = getattr(node, 'category', 'info') or getattr(node, 'type', 'info')

        if self.is_expression(str(message)):
            msg_expr = self.transpile_expression(str(message))
            self.emit(f"flash({msg_expr}, '{category}');")
        else:
            self.emit(f"flash('{message}', '{category}');")

        return ''

    # =========================================================================
    # Data Nodes (Phase 2)
    # =========================================================================

    def visit_QueryNode(self, node) -> str:
        """Generate database query (client-side fetch)."""
        name = getattr(node, 'name', 'result')
        endpoint = getattr(node, 'endpoint', None) or f'/api/query/{name}'

        self.emit(f'// Query: {name}')
        self.emit(f'const {name} = await fetch({repr(endpoint)}).then(r => r.json());')
        self.declare_var(name)

        return name

    def visit_DataNode(self, node) -> str:
        """Generate data import code."""
        name = getattr(node, 'name', 'data')
        source = getattr(node, 'source', '')
        data_type = getattr(node, 'data_type', None) or getattr(node, 'type', 'json')

        source_expr = self.transpile_expression(str(source)) if self.is_expression(str(source)) else repr(source)

        self.emit(f'// Data import: {name}')
        self.emit(f'const {name} = await fetch({source_expr}).then(r => r.json());')
        self.declare_var(name)

        return name

    def visit_InvokeNode(self, node) -> str:
        """Generate HTTP invocation."""
        name = getattr(node, 'name', 'result')
        url = getattr(node, 'url', None)
        method = getattr(node, 'method', 'GET')
        function = getattr(node, 'function', None)

        self.emit(f'// Invoke: {name}')

        if function:
            func_expr = self.transpile_expression(str(function)) if self.is_expression(str(function)) else function
            self.emit(f'const {name} = {func_expr}();')
        elif url:
            url_expr = self.transpile_expression(str(url)) if self.is_expression(str(url)) else repr(url)

            # Build headers and body from children
            headers = {}
            body = None
            for child in getattr(node, 'children', []) or []:
                child_type = type(child).__name__
                if child_type == 'InvokeHeaderNode':
                    headers[getattr(child, 'name', '')] = getattr(child, 'value', '')
                elif child_type == 'InvokeBodyNode':
                    body = getattr(child, 'content', None)

            self.emit(f'const {name} = await invoke({url_expr}, {{')
            self.indent()
            self.emit(f"method: '{method}',")
            if headers:
                import json
                self.emit(f'headers: {json.dumps(headers)},')
            if body:
                body_expr = self.transpile_expression(str(body)) if self.is_expression(str(body)) else repr(body)
                self.emit(f'body: {body_expr}')
            self.dedent()
            self.emit('});')
        else:
            self.emit(f'const {name} = null;')

        self.declare_var(name)
        return name

    def visit_FileNode(self, node) -> str:
        """Generate file upload code."""
        action = getattr(node, 'action', 'upload')
        file_var = getattr(node, 'file', '')
        result_var = getattr(node, 'result', None) or getattr(node, 'name', 'fileResult')

        file_expr = self.transpile_expression(str(file_var)) if self.is_expression(str(file_var)) else file_var

        self.emit(f'// File operation: {action}')
        if action == 'upload':
            self.emit(f'const formData = new FormData();')
            self.emit(f'formData.append("file", {file_expr});')
            self.emit(f'const {result_var} = await fetch("/api/upload", {{')
            self.indent()
            self.emit('method: "POST",')
            self.emit('body: formData')
            self.dedent()
            self.emit('}).then(r => r.json());')
        else:
            self.emit(f'const {result_var} = null;')

        self.declare_var(result_var)
        return result_var

    def visit_MailNode(self, node) -> str:
        """Generate email sending code (via API)."""
        to = getattr(node, 'to', '')
        from_addr = getattr(node, 'from_', '') or getattr(node, 'sender', '')
        subject = getattr(node, 'subject', '')

        to_expr = self.transpile_expression(str(to)) if self.is_expression(str(to)) else repr(to)
        subject_expr = self.transpile_expression(str(subject)) if self.is_expression(str(subject)) else repr(subject)

        self.emit('// Send email via API')
        self.emit('await fetch("/api/mail", {')
        self.indent()
        self.emit('method: "POST",')
        self.emit('headers: { "Content-Type": "application/json" },')
        self.emit(f'body: JSON.stringify({{ to: {to_expr}, subject: {subject_expr} }})')
        self.dedent()
        self.emit('});')

        return ''

    def visit_ActionNode(self, node) -> str:
        """Generate action handler."""
        name = getattr(node, 'name', 'action')
        method = getattr(node, 'method', 'POST')

        self.emit(f'// Action: {name}')
        self.emit(f'async function action_{name}(event) {{')
        self.indent()
        self.emit('event.preventDefault();')
        self.emit('const formData = new FormData(event.target);')
        self.emit_blank()

        self.push_scope()
        for child in getattr(node, 'children', []) or []:
            self.visit(child)
        self.pop_scope()

        self.dedent()
        self.emit('}')
        self.emit_blank()

        return f'action_{name}'

    # =========================================================================
    # Async Nodes (Phase 3)
    # =========================================================================

    def visit_JobNode(self, node) -> str:
        """Generate job queue code (Web Worker or setTimeout)."""
        name = getattr(node, 'name', 'job')
        action = getattr(node, 'action', 'define')
        delay = getattr(node, 'delay', None)

        self.emit(f'// Job: {name}')

        if action == 'define':
            self.emit(f'async function job_{name}(params) {{')
            self.indent()
            self.push_scope()
            for child in getattr(node, 'children', []) or []:
                self.visit(child)
            self.pop_scope()
            self.dedent()
            self.emit('}')
            self.emit_blank()
        elif action == 'dispatch':
            if delay:
                # Parse delay to milliseconds
                self.emit(f'setTimeout(() => job_{name}(), parseDelay({repr(delay)}));')
            else:
                self.emit(f'queueMicrotask(() => job_{name}());')

        return f'job_{name}'

    def visit_ScheduleNode(self, node) -> str:
        """Generate scheduled task (using setInterval)."""
        name = getattr(node, 'name', 'task')
        interval = getattr(node, 'interval', None)

        self.emit(f'// Scheduled task: {name}')

        self.emit(f'async function scheduled_{name}() {{')
        self.indent()
        self.push_scope()
        for child in getattr(node, 'children', []) or []:
            self.visit(child)
        self.pop_scope()
        self.dedent()
        self.emit('}')
        self.emit_blank()

        if interval:
            self.emit(f'const {name}_interval = setInterval(scheduled_{name}, parseDelay({repr(interval)}));')

        return f'scheduled_{name}'

    def visit_ThreadNode(self, node) -> str:
        """Generate async execution (Promise-based)."""
        name = getattr(node, 'name', 'thread')
        action = getattr(node, 'action', 'run')
        on_complete = getattr(node, 'on_complete', None) or getattr(node, 'onComplete', None)

        self.emit(f'// Async thread: {name}')

        if action == 'run':
            self.emit(f'const thread_{name} = (async () => {{')
            self.indent()
            self.push_scope()
            for child in getattr(node, 'children', []) or []:
                self.visit(child)
            self.pop_scope()
            self.dedent()
            if on_complete:
                self.emit(f'}})().then({on_complete});')
            else:
                self.emit('})();')
        elif action == 'join':
            self.emit(f'await thread_{name};')

        return f'thread_{name}'

    def visit_ParallelNode(self, node) -> str:
        """Generate parallel execution (Promise.all)."""
        name = getattr(node, 'name', 'parallel')

        self.emit(f'// Parallel execution: {name}')
        self.emit(f'const {name}_results = await Promise.all([')
        self.indent()

        for idx, child in enumerate(getattr(node, 'children', []) or []):
            child_type = type(child).__name__
            if child_type in ('ThreadNode', 'TaskNode', 'InvokeNode'):
                self.emit('(async () => {')
                self.indent()
                self.visit(child)
                self.dedent()
                self.emit('})(),')
            else:
                self.visit(child)

        self.dedent()
        self.emit(']);')
        self.declare_var(f'{name}_results')

        return name

    # =========================================================================
    # Comments
    # =========================================================================

    def emit_comment(self, comment: str):
        """Emit JavaScript comment."""
        self.emit(f'// {comment}')
