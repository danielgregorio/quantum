"""
Nginx Service - Configuration generation and management for nginx-proxy-manager
"""

import os
import logging
import subprocess
import tempfile
from pathlib import Path
from typing import Optional
from jinja2 import Template

logger = logging.getLogger(__name__)

# Location block template for each app
NGINX_LOCATION_TEMPLATE = """    # Quantum App: {{ app_name }}
    location /{{ app_name }}/ {
        proxy_pass http://{{ container_name }}:{{ port }}/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Prefix /{{ app_name }};
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $http_connection;
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
    }
"""

# Full server block template
NGINX_SERVER_TEMPLATE = """# Quantum Apps - Auto-generated by Quantum Deploy Service
# DO NOT EDIT MANUALLY - this file is regenerated on each deploy

server {
    listen 80;
    listen [::]:80;

    server_name {{ server_name }};

    access_log /data/logs/quantum_access.log;
    error_log /data/logs/quantum_error.log warn;

{{ location_blocks }}
    # Default - app listing
    location / {
        default_type text/html;
        return 200 '{{ index_html }}';
    }
}
"""


class NginxService:
    """Service for managing nginx configurations via nginx-proxy-manager."""

    def __init__(self):
        """Initialize nginx service."""
        self.config_dir = Path(os.environ.get('QUANTUM_NGINX_DIR', '/data/quantum/nginx'))
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.npm_container = os.environ.get('NPM_CONTAINER', 'nginx-proxy-manager')
        self.server_name = os.environ.get('QUANTUM_SERVER_NAME', '10.10.1.40')
        self.location_template = Template(NGINX_LOCATION_TEMPLATE)

    def add_app_config(
        self,
        app_name: str,
        container_name: str,
        port: int = 8080
    ) -> Path:
        """
        Generate nginx config for an app and rebuild combined config.

        Args:
            app_name: Application name (used for routing path)
            container_name: Docker container name
            port: Internal container port (default: 8080)

        Returns:
            Path to generated config file
        """
        config_content = self.location_template.render(
            app_name=app_name,
            container_name=container_name,
            port=port
        )

        # Save individual config for reference
        config_path = self.config_dir / f"{app_name}.conf"
        with open(config_path, 'w') as f:
            f.write(config_content)

        logger.info(f"Generated nginx config: {config_path}")

        # Rebuild combined config
        self._rebuild_combined_config()

        return config_path

    def remove_app_config(self, app_name: str) -> bool:
        """
        Remove nginx config for an app and rebuild combined config.

        Args:
            app_name: Application name

        Returns:
            True if config was removed
        """
        config_path = self.config_dir / f"{app_name}.conf"

        if config_path.exists():
            config_path.unlink()
            logger.info(f"Removed nginx config: {config_path}")
            self._rebuild_combined_config()
            return True

        logger.warning(f"Nginx config not found: {config_path}")
        return False

    def _rebuild_combined_config(self):
        """Rebuild the combined http.conf from all individual app configs."""
        # Collect all location blocks
        location_blocks = ""
        app_names = []

        for config_file in sorted(self.config_dir.glob("*.conf")):
            location_blocks += config_file.read_text() + "\n"
            app_names.append(config_file.stem)

        # Build index HTML
        links = "".join(
            f'<li><a href="/{name}/">{name}</a></li>'
            for name in sorted(app_names)
        )
        index_html = (
            '<html><head><title>Quantum Apps</title>'
            '<style>'
            'body{background:#0f172a;color:#e2e8f0;font-family:sans-serif;padding:40px}'
            'a{color:#818cf8;text-decoration:none}a:hover{text-decoration:underline}'
            'h1{color:#6366f1}li{margin:8px 0;font-size:1.1rem}'
            '</style></head><body>'
            '<h1>Quantum Apps on Forge</h1>'
            f'<ul>{links}</ul>'
            '</body></html>'
        )

        # Build combined server block
        combined = Template(NGINX_SERVER_TEMPLATE).render(
            server_name=self.server_name,
            location_blocks=location_blocks,
            index_html=index_html
        )

        # Write to temp file and copy into NPM container
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.conf', delete=False) as f:
                f.write(combined)
                tmp_path = f.name

            # Ensure custom dir exists in NPM
            subprocess.run(
                ['docker', 'exec', self.npm_container, 'mkdir', '-p', '/data/nginx/custom/'],
                capture_output=True, timeout=10
            )

            # Copy into NPM container
            subprocess.run(
                ['docker', 'cp', tmp_path, f'{self.npm_container}:/data/nginx/custom/http.conf'],
                capture_output=True, timeout=10, check=True
            )

            logger.info("Combined nginx config copied to NPM container")

            # Cleanup temp file
            os.unlink(tmp_path)

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to copy config to NPM: {e}")
        except Exception as e:
            logger.error(f"Failed to rebuild combined config: {e}")

    def reload(self) -> bool:
        """
        Reload nginx configuration via NPM container.

        Returns:
            True if reload was successful
        """
        try:
            # Test configuration first
            result = subprocess.run(
                ['docker', 'exec', self.npm_container, 'nginx', '-t'],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode != 0:
                logger.error(f"Nginx config test failed: {result.stderr}")
                return False

            # Reload nginx
            result = subprocess.run(
                ['docker', 'exec', self.npm_container, 'nginx', '-s', 'reload'],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode != 0:
                logger.error(f"Nginx reload failed: {result.stderr}")
                return False

            logger.info("Nginx reloaded successfully")
            return True

        except subprocess.TimeoutExpired:
            logger.error("Nginx reload timed out")
            return False
        except FileNotFoundError:
            logger.warning("Docker not found - skipping reload")
            return True
        except Exception as e:
            logger.error(f"Failed to reload nginx: {e}")
            return False

    def get_app_config(self, app_name: str) -> Optional[str]:
        """
        Get nginx config content for an app.

        Args:
            app_name: Application name

        Returns:
            Config content or None if not found
        """
        config_path = self.config_dir / f"{app_name}.conf"

        if config_path.exists():
            return config_path.read_text()

        return None

    def list_configs(self) -> list:
        """List all app configurations."""
        configs = []
        for config_file in self.config_dir.glob("*.conf"):
            configs.append({
                'name': config_file.stem,
                'path': str(config_file),
                'size': config_file.stat().st_size
            })
        return configs

    def validate_config(self) -> tuple:
        """
        Validate nginx configuration.

        Returns:
            Tuple of (is_valid, error_message)
        """
        try:
            result = subprocess.run(
                ['docker', 'exec', self.npm_container, 'nginx', '-t'],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                return True, "Configuration is valid"
            else:
                return False, result.stderr

        except FileNotFoundError:
            return True, "Docker not found - skipping validation"
        except Exception as e:
            return False, str(e)
