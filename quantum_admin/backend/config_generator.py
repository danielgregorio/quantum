"""
Config Generator - Generate configuration files for projects

Generates:
- .env files
- docker-compose.yml
- nginx.conf
- systemd service files
"""

import os
import json
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
from sqlalchemy.orm import Session

try:
    from .models import Project, Environment, Datasource, PortAllocation, Secret, ServiceRegistry
    from .resource_manager import get_resource_manager
except ImportError:
    from models import Project, Environment, Datasource, PortAllocation, Secret, ServiceRegistry
    from resource_manager import get_resource_manager

logger = logging.getLogger(__name__)


class ConfigGenerator:
    """Generate configuration files for projects"""

    def __init__(self, db: Session):
        self.db = db
        self.resource_manager = get_resource_manager(db)

    def generate_env_file(
        self,
        project_id: int,
        environment_id: int = None,
        include_secrets: bool = True
    ) -> str:
        """
        Generate a .env file content for a project

        Args:
            project_id: Project ID
            environment_id: Optional environment ID for environment-specific vars
            include_secrets: Include decrypted secret values

        Returns:
            String content of .env file
        """
        project = self.db.query(Project).filter(Project.id == project_id).first()
        if not project:
            raise ValueError(f"Project {project_id} not found")

        lines = [
            f"# Generated by Quantum Admin - {datetime.now().isoformat()}",
            f"# Project: {project.name}",
            ""
        ]

        # Get environment if specified
        environment = None
        if environment_id:
            environment = self.db.query(Environment).filter(
                Environment.id == environment_id
            ).first()
            if environment:
                lines.append(f"# Environment: {environment.name}")
                lines.append("")

        # Add project-level config
        lines.append("# Application")
        lines.append(f"APP_NAME={project.name}")
        lines.append(f"APP_ENV={'production' if environment and environment.name == 'production' else 'development'}")
        lines.append("")

        # Get port allocations
        ports = self.db.query(PortAllocation).filter(
            PortAllocation.project_id == project_id,
            PortAllocation.status == 'allocated'
        )
        if environment_id:
            ports = ports.filter(PortAllocation.environment_id == environment_id)
        ports = ports.all()

        if ports:
            lines.append("# Ports")
            for port in ports:
                var_name = f"{port.service_name.upper().replace('-', '_')}_PORT"
                lines.append(f"{var_name}={port.port}")
            lines.append("")

        # Get secrets
        if include_secrets:
            secrets = self.resource_manager.secrets.list_secrets(
                project_id=project_id,
                environment_id=environment_id
            )
            if secrets:
                lines.append("# Secrets")
                for secret in secrets:
                    value = self.resource_manager.secrets.get(
                        secret.key,
                        project_id=project_id,
                        environment_id=environment_id
                    )
                    if value:
                        lines.append(f"{secret.key}={value}")
                lines.append("")

        # Get datasources
        datasources = self.db.query(Datasource).filter(
            Datasource.project_id == project_id
        ).all()

        if datasources:
            lines.append("# Databases")
            for ds in datasources:
                prefix = ds.name.upper().replace('-', '_')
                lines.append(f"{prefix}_HOST={ds.host or 'localhost'}")
                lines.append(f"{prefix}_PORT={ds.port or 5432}")
                lines.append(f"{prefix}_NAME={ds.database_name or ds.name}")
                if ds.username:
                    lines.append(f"{prefix}_USER={ds.username}")
                # Don't include encrypted password - use secrets instead
            lines.append("")

        # Get services
        services = self.resource_manager.services.list_services(
            project_id=project_id,
            environment_id=environment_id
        )

        if services:
            lines.append("# Services")
            for svc in services:
                prefix = svc.name.upper().replace('-', '_')
                lines.append(f"{prefix}_URL={svc.protocol}://{svc.host}:{svc.port}")
            lines.append("")

        return "\n".join(lines)

    def generate_docker_compose(
        self,
        project_id: int,
        environment_id: int = None,
        include_databases: bool = True,
        include_cache: bool = True
    ) -> str:
        """
        Generate a docker-compose.yml content for a project

        Args:
            project_id: Project ID
            environment_id: Optional environment ID
            include_databases: Include database containers
            include_cache: Include Redis cache

        Returns:
            String content of docker-compose.yml
        """
        project = self.db.query(Project).filter(Project.id == project_id).first()
        if not project:
            raise ValueError(f"Project {project_id} not found")

        # Get environment for naming
        env_name = "dev"
        environment = None
        if environment_id:
            environment = self.db.query(Environment).filter(
                Environment.id == environment_id
            ).first()
            if environment:
                env_name = environment.name

        # Get port allocations
        ports = self.db.query(PortAllocation).filter(
            PortAllocation.project_id == project_id,
            PortAllocation.status == 'allocated'
        )
        if environment_id:
            ports = ports.filter(PortAllocation.environment_id == environment_id)
        ports_list = ports.all()

        # Find app port
        app_port = 8000
        for p in ports_list:
            if p.port_type == 'app':
                app_port = p.port
                break

        # Build compose content
        compose = {
            "version": "3.8",
            "services": {},
            "networks": {
                "quantum-network": {
                    "driver": "bridge"
                }
            },
            "volumes": {}
        }

        # Main app service
        service_name = f"{project.name.lower().replace(' ', '-')}-app"
        compose["services"][service_name] = {
            "build": ".",
            "container_name": f"{project.name.lower()}-{env_name}",
            "ports": [f"{app_port}:8000"],
            "environment": [
                f"APP_NAME={project.name}",
                f"APP_ENV={env_name}",
            ],
            "networks": ["quantum-network"],
            "restart": "unless-stopped"
        }

        # Get datasources
        if include_databases:
            datasources = self.db.query(Datasource).filter(
                Datasource.project_id == project_id
            ).all()

            for ds in datasources:
                ds_name = ds.name.lower().replace(' ', '-')
                ds_port = ds.port or self._get_default_db_port(ds.type)

                if ds.type == 'postgres':
                    compose["services"][f"{ds_name}-db"] = {
                        "image": "postgres:15-alpine",
                        "container_name": f"{ds_name}-{env_name}",
                        "environment": [
                            f"POSTGRES_DB={ds.database_name or ds.name}",
                            f"POSTGRES_USER={ds.username or 'quantum'}",
                            "POSTGRES_PASSWORD=${DB_PASSWORD:-quantum123}"
                        ],
                        "ports": [f"{ds_port}:5432"],
                        "volumes": [f"{ds_name}-data:/var/lib/postgresql/data"],
                        "networks": ["quantum-network"],
                        "restart": "unless-stopped"
                    }
                    compose["volumes"][f"{ds_name}-data"] = None

                elif ds.type == 'mysql':
                    compose["services"][f"{ds_name}-db"] = {
                        "image": "mysql:8",
                        "container_name": f"{ds_name}-{env_name}",
                        "environment": [
                            f"MYSQL_DATABASE={ds.database_name or ds.name}",
                            f"MYSQL_USER={ds.username or 'quantum'}",
                            "MYSQL_PASSWORD=${DB_PASSWORD:-quantum123}",
                            "MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD:-root123}"
                        ],
                        "ports": [f"{ds_port}:3306"],
                        "volumes": [f"{ds_name}-data:/var/lib/mysql"],
                        "networks": ["quantum-network"],
                        "restart": "unless-stopped"
                    }
                    compose["volumes"][f"{ds_name}-data"] = None

                elif ds.type == 'mongodb':
                    compose["services"][f"{ds_name}-db"] = {
                        "image": "mongo:6",
                        "container_name": f"{ds_name}-{env_name}",
                        "environment": [
                            f"MONGO_INITDB_DATABASE={ds.database_name or ds.name}",
                        ],
                        "ports": [f"{ds_port}:27017"],
                        "volumes": [f"{ds_name}-data:/data/db"],
                        "networks": ["quantum-network"],
                        "restart": "unless-stopped"
                    }
                    compose["volumes"][f"{ds_name}-data"] = None

        # Add Redis cache
        if include_cache:
            cache_port = 6379
            for p in ports_list:
                if p.port_type == 'cache':
                    cache_port = p.port
                    break

            compose["services"]["redis"] = {
                "image": "redis:7-alpine",
                "container_name": f"{project.name.lower()}-redis-{env_name}",
                "ports": [f"{cache_port}:6379"],
                "networks": ["quantum-network"],
                "restart": "unless-stopped"
            }

        # Convert to YAML format
        return self._dict_to_yaml(compose)

    def generate_nginx_conf(
        self,
        project_id: int,
        environment_id: int = None,
        domain: str = None,
        ssl: bool = True
    ) -> str:
        """
        Generate nginx configuration for a project

        Args:
            project_id: Project ID
            environment_id: Optional environment ID
            domain: Domain name (defaults to localhost)
            ssl: Enable SSL configuration

        Returns:
            String content of nginx.conf
        """
        project = self.db.query(Project).filter(Project.id == project_id).first()
        if not project:
            raise ValueError(f"Project {project_id} not found")

        # Get environment
        env_name = "dev"
        environment = None
        if environment_id:
            environment = self.db.query(Environment).filter(
                Environment.id == environment_id
            ).first()
            if environment:
                env_name = environment.name

        # Get app port
        ports = self.db.query(PortAllocation).filter(
            PortAllocation.project_id == project_id,
            PortAllocation.port_type == 'app',
            PortAllocation.status == 'allocated'
        )
        if environment_id:
            ports = ports.filter(PortAllocation.environment_id == environment_id)
        port_alloc = ports.first()
        app_port = port_alloc.port if port_alloc else 8000

        # Determine domain
        if not domain:
            if environment and hasattr(environment, 'health_url') and environment.health_url:
                # Extract domain from health URL
                from urllib.parse import urlparse
                parsed = urlparse(environment.health_url)
                domain = parsed.netloc.split(':')[0]
            else:
                domain = "localhost"

        upstream_name = f"{project.name.lower().replace(' ', '_')}_upstream"

        conf_lines = [
            f"# Nginx configuration for {project.name} ({env_name})",
            f"# Generated by Quantum Admin - {datetime.now().isoformat()}",
            "",
            f"upstream {upstream_name} {{",
            f"    server 127.0.0.1:{app_port};",
            "    keepalive 32;",
            "}",
            "",
        ]

        # HTTP to HTTPS redirect if SSL
        if ssl:
            conf_lines.extend([
                "server {",
                "    listen 80;",
                f"    server_name {domain};",
                "",
                "    location / {",
                "        return 301 https://$host$request_uri;",
                "    }",
                "}",
                "",
            ])

        # Main server block
        if ssl:
            conf_lines.extend([
                "server {",
                "    listen 443 ssl http2;",
                f"    server_name {domain};",
                "",
                f"    ssl_certificate /etc/letsencrypt/live/{domain}/fullchain.pem;",
                f"    ssl_certificate_key /etc/letsencrypt/live/{domain}/privkey.pem;",
                "    ssl_protocols TLSv1.2 TLSv1.3;",
                "    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;",
                "    ssl_prefer_server_ciphers off;",
                "",
            ])
        else:
            conf_lines.extend([
                "server {",
                "    listen 80;",
                f"    server_name {domain};",
                "",
            ])

        conf_lines.extend([
            "    # Logging",
            f"    access_log /var/log/nginx/{project.name.lower()}-access.log;",
            f"    error_log /var/log/nginx/{project.name.lower()}-error.log;",
            "",
            "    # Security headers",
            "    add_header X-Frame-Options \"SAMEORIGIN\" always;",
            "    add_header X-Content-Type-Options \"nosniff\" always;",
            "    add_header X-XSS-Protection \"1; mode=block\" always;",
            "",
            "    # Gzip compression",
            "    gzip on;",
            "    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;",
            "",
            "    # Static files",
            "    location /static/ {",
            "        alias /var/www/{project.name.lower()}/static/;",
            "        expires 30d;",
            "        add_header Cache-Control \"public, immutable\";",
            "    }",
            "",
            "    # Proxy to application",
            "    location / {",
            f"        proxy_pass http://{upstream_name};",
            "        proxy_http_version 1.1;",
            "        proxy_set_header Host $host;",
            "        proxy_set_header X-Real-IP $remote_addr;",
            "        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;",
            "        proxy_set_header X-Forwarded-Proto $scheme;",
            "        proxy_set_header Connection \"\";",
            "",
            "        # Timeouts",
            "        proxy_connect_timeout 60s;",
            "        proxy_send_timeout 60s;",
            "        proxy_read_timeout 60s;",
            "    }",
            "",
            "    # WebSocket support",
            "    location /ws/ {",
            f"        proxy_pass http://{upstream_name};",
            "        proxy_http_version 1.1;",
            "        proxy_set_header Upgrade $http_upgrade;",
            "        proxy_set_header Connection \"upgrade\";",
            "        proxy_set_header Host $host;",
            "        proxy_read_timeout 86400;",
            "    }",
            "",
            "    # Health check endpoint",
            "    location /health {",
            f"        proxy_pass http://{upstream_name}/health;",
            "        access_log off;",
            "    }",
            "}",
        ])

        return "\n".join(conf_lines)

    def generate_systemd_service(
        self,
        project_id: int,
        environment_id: int = None,
        working_dir: str = None,
        python_path: str = None
    ) -> str:
        """
        Generate systemd service file for a project

        Args:
            project_id: Project ID
            environment_id: Optional environment ID
            working_dir: Working directory (defaults to /var/www/{project})
            python_path: Python executable path

        Returns:
            String content of systemd service file
        """
        project = self.db.query(Project).filter(Project.id == project_id).first()
        if not project:
            raise ValueError(f"Project {project_id} not found")

        env_name = "dev"
        if environment_id:
            environment = self.db.query(Environment).filter(
                Environment.id == environment_id
            ).first()
            if environment:
                env_name = environment.name

        project_slug = project.name.lower().replace(' ', '-')
        if not working_dir:
            working_dir = f"/var/www/{project_slug}"
        if not python_path:
            python_path = f"{working_dir}/venv/bin/python"

        # Get app port
        ports = self.db.query(PortAllocation).filter(
            PortAllocation.project_id == project_id,
            PortAllocation.port_type == 'app',
            PortAllocation.status == 'allocated'
        )
        if environment_id:
            ports = ports.filter(PortAllocation.environment_id == environment_id)
        port_alloc = ports.first()
        app_port = port_alloc.port if port_alloc else 8000

        service_lines = [
            f"# Systemd service for {project.name} ({env_name})",
            f"# Generated by Quantum Admin - {datetime.now().isoformat()}",
            "",
            "[Unit]",
            f"Description={project.name} Quantum Application ({env_name})",
            "After=network.target postgresql.service redis.service",
            "Wants=postgresql.service redis.service",
            "",
            "[Service]",
            "Type=simple",
            f"User=www-data",
            f"Group=www-data",
            f"WorkingDirectory={working_dir}",
            f"Environment=APP_ENV={env_name}",
            f"EnvironmentFile={working_dir}/.env",
            f"ExecStart={python_path} -m uvicorn main:app --host 0.0.0.0 --port {app_port}",
            "Restart=always",
            "RestartSec=5",
            "StandardOutput=journal",
            "StandardError=journal",
            "",
            "# Security",
            "NoNewPrivileges=true",
            "ProtectSystem=strict",
            f"ReadWritePaths={working_dir}",
            "PrivateTmp=true",
            "",
            "[Install]",
            "WantedBy=multi-user.target",
        ]

        return "\n".join(service_lines)

    def _get_default_db_port(self, db_type: str) -> int:
        """Get default port for database type"""
        defaults = {
            'postgres': 5432,
            'mysql': 3306,
            'mongodb': 27017,
            'redis': 6379,
        }
        return defaults.get(db_type, 5432)

    def _dict_to_yaml(self, data: Dict, indent: int = 0) -> str:
        """Simple dict to YAML converter"""
        lines = []
        prefix = "  " * indent

        for key, value in data.items():
            if value is None:
                lines.append(f"{prefix}{key}:")
            elif isinstance(value, dict):
                lines.append(f"{prefix}{key}:")
                lines.append(self._dict_to_yaml(value, indent + 1))
            elif isinstance(value, list):
                lines.append(f"{prefix}{key}:")
                for item in value:
                    if isinstance(item, dict):
                        lines.append(f"{prefix}  -")
                        for k, v in item.items():
                            lines.append(f"{prefix}    {k}: {v}")
                    else:
                        lines.append(f"{prefix}  - {item}")
            else:
                lines.append(f"{prefix}{key}: {value}")

        return "\n".join(lines)


# Singleton instance
_config_generator = None


def get_config_generator(db: Session = None) -> ConfigGenerator:
    """Get config generator instance"""
    if db:
        return ConfigGenerator(db)

    global _config_generator
    if _config_generator is None:
        from .database import SessionLocal
        _config_generator = ConfigGenerator(SessionLocal())
    return _config_generator
