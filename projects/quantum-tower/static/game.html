<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #111; display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; }
    canvas { display: block; }
    .qg-hud { position: absolute; pointer-events: none; padding: 8px; font-family: sans-serif; z-index: 10; }
    .qg-hud-top-left { top: 0; left: 0; }
    .qg-hud-top-right { top: 0; right: 0; }
    .qg-hud-top-center { top: 0; left: 50%; transform: translateX(-50%); }
    .qg-hud-bottom-left { bottom: 0; left: 0; }
    .qg-hud-bottom-right { bottom: 0; right: 0; }
    .qg-hud-bottom-center { bottom: 0; left: 50%; transform: translateX(-50%); }
    .qg-hud-center { top: 50%; left: 50%; transform: translate(-50%, -50%); }

    /* Source Code Viewer */
    #qg-source-btn {
      position: fixed;
      bottom: 16px;
      right: 16px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-family: monospace;
      font-size: 12px;
      transition: all 0.2s;
    }
    #qg-source-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.9);
    }
    #qg-source-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.92);
      z-index: 999;
      overflow: auto;
    }
    #qg-source-modal.visible {
      display: flex;
      flex-direction: column;
    }
    #qg-source-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-family: monospace;
      font-size: 13px;
      z-index: 1001;
    }
    #qg-source-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    #qg-source-content {
      flex: 1;
      overflow: auto;
      padding: 48px 24px 24px;
    }
    #qg-source-content pre {
      background: #1e1e2e;
      color: #cdd6f4;
      padding: 24px;
      border-radius: 12px;
      font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      line-height: 1.7;
      overflow-x: auto;
      white-space: pre;
      tab-size: 2;
      border: 1px solid #313244;
      max-width: 900px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div class="qg-hud qg-hud-top-left" id="qg-hud-0"><text style="color:#FFD700;font-size:18px;font-weight:bold;">Gold: {gold}</text><text style="color:#FF4444;font-size:18px;margin-left:20px;">Lives: {lives}</text><text style="color:#FFFFFF;font-size:18px;margin-left:20px;">Wave: {waveNumber}</text></div>
  <div class="qg-hud qg-hud-bottom-center" id="qg-hud-1"><text style="color:#AAAAAA;font-size:14px;">Click green slots to place towers ({towerCost}g)</text></div>
  <button id="qg-source-btn" onclick="toggleSource()">source</button>
  <div id="qg-source-modal">
    <button id="qg-source-close" onclick="toggleSource()">ESC</button>
    <div id="qg-source-content">
      <pre id="qg-source-code">&lt;q:application id=&quot;tower-defense&quot; type=&quot;game&quot; engine=&quot;2d&quot;&gt;

  &lt;qg:scene name=&quot;battlefield&quot; width=&quot;800&quot; height=&quot;600&quot; background=&quot;#2d5a1e&quot;&gt;

    &lt;qg:physics gravity-x=&quot;0&quot; gravity-y=&quot;0&quot; /&gt;

    &lt;!-- Game State --&gt;
    &lt;q:set name=&quot;gold&quot; value=&quot;100&quot; type=&quot;integer&quot; /&gt;
    &lt;q:set name=&quot;lives&quot; value=&quot;20&quot; type=&quot;integer&quot; /&gt;
    &lt;q:set name=&quot;waveNumber&quot; value=&quot;0&quot; type=&quot;integer&quot; /&gt;
    &lt;q:set name=&quot;towerCost&quot; value=&quot;25&quot; type=&quot;integer&quot; /&gt;
    &lt;q:set name=&quot;enemiesPerWave&quot; value=&quot;5&quot; type=&quot;integer&quot; /&gt;
    &lt;q:set name=&quot;waveActive&quot; value=&quot;false&quot; type=&quot;boolean&quot; /&gt;

    &lt;!-- Path waypoints for enemies --&gt;
    &lt;q:set name=&quot;pathX&quot; value=&quot;[0,200,200,600,600,800]&quot; /&gt;
    &lt;q:set name=&quot;pathY&quot; value=&quot;[300,300,150,150,450,450]&quot; /&gt;

    &lt;!-- Path tiles (visual) --&gt;
    &lt;qg:sprite id=&quot;path0&quot; src=&quot;&quot; x=&quot;0&quot;   y=&quot;275&quot; width=&quot;225&quot; height=&quot;50&quot; body=&quot;static&quot; color=&quot;#8B7355&quot; /&gt;
    &lt;qg:sprite id=&quot;path1&quot; src=&quot;&quot; x=&quot;175&quot; y=&quot;150&quot; width=&quot;50&quot;  height=&quot;175&quot; body=&quot;static&quot; color=&quot;#8B7355&quot; /&gt;
    &lt;qg:sprite id=&quot;path2&quot; src=&quot;&quot; x=&quot;200&quot; y=&quot;125&quot; width=&quot;425&quot; height=&quot;50&quot;  body=&quot;static&quot; color=&quot;#8B7355&quot; /&gt;
    &lt;qg:sprite id=&quot;path3&quot; src=&quot;&quot; x=&quot;575&quot; y=&quot;150&quot; width=&quot;50&quot;  height=&quot;325&quot; body=&quot;static&quot; color=&quot;#8B7355&quot; /&gt;
    &lt;qg:sprite id=&quot;path4&quot; src=&quot;&quot; x=&quot;600&quot; y=&quot;425&quot; width=&quot;200&quot; height=&quot;50&quot;  body=&quot;static&quot; color=&quot;#8B7355&quot; /&gt;

    &lt;!-- Placement grid (clickable slots for towers) --&gt;
    &lt;qg:sprite id=&quot;slot0&quot; src=&quot;&quot; x=&quot;100&quot; y=&quot;400&quot; width=&quot;48&quot; height=&quot;48&quot; body=&quot;static&quot; tag=&quot;slot&quot; color=&quot;#4ade80&quot;&gt;
      &lt;qg:clickable action=&quot;placeTower&quot; cursor=&quot;crosshair&quot; /&gt;
    &lt;/qg:sprite&gt;
    &lt;qg:sprite id=&quot;slot1&quot; src=&quot;&quot; x=&quot;300&quot; y=&quot;80&quot;  width=&quot;48&quot; height=&quot;48&quot; body=&quot;static&quot; tag=&quot;slot&quot; color=&quot;#4ade80&quot;&gt;
      &lt;qg:clickable action=&quot;placeTower&quot; cursor=&quot;crosshair&quot; /&gt;
    &lt;/qg:sprite&gt;
    &lt;qg:sprite id=&quot;slot2&quot; src=&quot;&quot; x=&quot;400&quot; y=&quot;80&quot;  width=&quot;48&quot; height=&quot;48&quot; body=&quot;static&quot; tag=&quot;slot&quot; color=&quot;#4ade80&quot;&gt;
      &lt;qg:clickable action=&quot;placeTower&quot; cursor=&quot;crosshair&quot; /&gt;
    &lt;/qg:sprite&gt;
    &lt;qg:sprite id=&quot;slot3&quot; src=&quot;&quot; x=&quot;500&quot; y=&quot;200&quot; width=&quot;48&quot; height=&quot;48&quot; body=&quot;static&quot; tag=&quot;slot&quot; color=&quot;#4ade80&quot;&gt;
      &lt;qg:clickable action=&quot;placeTower&quot; cursor=&quot;crosshair&quot; /&gt;
    &lt;/qg:sprite&gt;
    &lt;qg:sprite id=&quot;slot4&quot; src=&quot;&quot; x=&quot;500&quot; y=&quot;500&quot; width=&quot;48&quot; height=&quot;48&quot; body=&quot;static&quot; tag=&quot;slot&quot; color=&quot;#4ade80&quot;&gt;
      &lt;qg:clickable action=&quot;placeTower&quot; cursor=&quot;crosshair&quot; /&gt;
    &lt;/qg:sprite&gt;
    &lt;qg:sprite id=&quot;slot5&quot; src=&quot;&quot; x=&quot;700&quot; y=&quot;350&quot; width=&quot;48&quot; height=&quot;48&quot; body=&quot;static&quot; tag=&quot;slot&quot; color=&quot;#4ade80&quot;&gt;
      &lt;qg:clickable action=&quot;placeTower&quot; cursor=&quot;crosshair&quot; /&gt;
    &lt;/qg:sprite&gt;

    &lt;!-- Behaviors --&gt;
    &lt;qg:behavior name=&quot;Enemy&quot;&gt;
      &lt;q:set name=&quot;hp&quot; value=&quot;3&quot; type=&quot;integer&quot; /&gt;
      &lt;q:set name=&quot;speed&quot; value=&quot;80&quot; type=&quot;integer&quot; /&gt;
      &lt;q:set name=&quot;waypointIndex&quot; value=&quot;0&quot; type=&quot;integer&quot; /&gt;

      &lt;qg:state-machine initial=&quot;walk&quot;&gt;
        &lt;qg:state name=&quot;walk&quot;&gt;
          &lt;q:function name=&quot;update&quot;&gt;
            var idx = this.owner.waypointIndex;
            var px = game.getVar(&#x27;pathX&#x27;);
            var py = game.getVar(&#x27;pathY&#x27;);
            if (idx &gt;= px.length) {
              game.addVar(&#x27;lives&#x27;, -1);
              game.destroy(this.owner);
              return;
            }
            var tx = px[idx]; var ty = py[idx];
            var dx = tx - this.owner.x;
            var dy = ty - this.owner.y;
            var dist = Math.sqrt(dx*dx + dy*dy);
            if (dist &amp;lt; 5) {
              this.owner.waypointIndex = idx + 1;
            } else {
              game.moveX(this.owner, (dx/dist) * this.owner.speed * game.dt);
              game.moveY(this.owner, (dy/dist) * this.owner.speed * game.dt);
            }
          &lt;/q:function&gt;
          &lt;qg:on event=&quot;hit&quot; transition=&quot;hit&quot; /&gt;
        &lt;/qg:state&gt;

        &lt;qg:state name=&quot;hit&quot;&gt;
          &lt;q:function name=&quot;enter&quot;&gt;
            this.owner.hp -= 1;
            if (this.owner.hp &amp;lt;= 0) {
              this._smEmit(&#x27;dead&#x27;);
            } else {
              this._smEmit(&#x27;recover&#x27;);
            }
          &lt;/q:function&gt;
          &lt;qg:on event=&quot;recover&quot; transition=&quot;walk&quot; /&gt;
          &lt;qg:on event=&quot;dead&quot; transition=&quot;die&quot; /&gt;
        &lt;/qg:state&gt;

        &lt;qg:state name=&quot;die&quot;&gt;
          &lt;q:function name=&quot;enter&quot;&gt;
            game.addVar(&#x27;gold&#x27;, 10);
            game.play(&#x27;killSound&#x27;);
            game.destroy(this.owner);
          &lt;/q:function&gt;
        &lt;/qg:state&gt;
      &lt;/qg:state-machine&gt;
    &lt;/qg:behavior&gt;

    &lt;qg:behavior name=&quot;Tower&quot;&gt;
      &lt;q:set name=&quot;range&quot; value=&quot;120&quot; type=&quot;integer&quot; /&gt;
      &lt;q:set name=&quot;fireRate&quot; value=&quot;1.0&quot; /&gt;
      &lt;q:set name=&quot;cooldown&quot; value=&quot;0.0&quot; /&gt;

      &lt;q:function name=&quot;update&quot;&gt;
        this.owner.cooldown -= game.dt;
        if (this.owner.cooldown &gt; 0) return;
        var enemies = game.findByTag(&#x27;enemy&#x27;);
        for (var i = 0; i &amp;lt; enemies.length; i++) {
          var e = enemies[i];
          var dx = e.x - this.owner.x;
          var dy = e.y - this.owner.y;
          var dist = Math.sqrt(dx*dx + dy*dy);
          if (dist &amp;lt; this.owner.range) {
            game.spawn(&#x27;bulletSpawner&#x27;, this.owner.x, this.owner.y);
            var bullets = game.findByTag(&#x27;bullet&#x27;);
            var b = bullets[bullets.length - 1];
            if (b) b.targetId = e.id;
            this.owner.cooldown = this.owner.fireRate;
            game.play(&#x27;shootSound&#x27;);
            break;
          }
        }
      &lt;/q:function&gt;
    &lt;/qg:behavior&gt;

    &lt;qg:behavior name=&quot;Bullet&quot;&gt;
      &lt;q:set name=&quot;speed&quot; value=&quot;250&quot; type=&quot;integer&quot; /&gt;
      &lt;q:set name=&quot;targetId&quot; value=&quot;&quot; type=&quot;string&quot; /&gt;

      &lt;q:function name=&quot;update&quot;&gt;
        if (!this.owner.targetId) { game.destroy(this.owner); return; }
        var target = game.findById(this.owner.targetId);
        if (!target) { game.destroy(this.owner); return; }
        var arrived = game.moveToward(this.owner, target.id, this.owner.speed);
        if (arrived) {
          target._smEmit(&#x27;hit&#x27;);
          game.destroy(this.owner);
        }
      &lt;/q:function&gt;
    &lt;/qg:behavior&gt;

    &lt;!-- Prefabs --&gt;
    &lt;qg:prefab name=&quot;EnemyPrefab&quot;&gt;
      &lt;qg:sprite id=&quot;enemy&quot; src=&quot;&quot; width=&quot;32&quot; height=&quot;32&quot; body=&quot;kinematic&quot; tag=&quot;enemy&quot; color=&quot;#e74c3c&quot;&gt;
        &lt;qg:use behavior=&quot;Enemy&quot; /&gt;
      &lt;/qg:sprite&gt;
    &lt;/qg:prefab&gt;

    &lt;qg:prefab name=&quot;BulletPrefab&quot;&gt;
      &lt;qg:sprite id=&quot;bullet&quot; src=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; body=&quot;dynamic&quot; tag=&quot;bullet&quot; sensor=&quot;true&quot; color=&quot;#f1c40f&quot;&gt;
        &lt;qg:use behavior=&quot;Bullet&quot; /&gt;
      &lt;/qg:sprite&gt;
    &lt;/qg:prefab&gt;

    &lt;!-- Spawners --&gt;
    &lt;qg:spawn id=&quot;enemySpawner&quot;  prefab=&quot;EnemyPrefab&quot;  pool-size=&quot;30&quot; x=&quot;0&quot; y=&quot;300&quot; /&gt;
    &lt;qg:spawn id=&quot;bulletSpawner&quot; prefab=&quot;BulletPrefab&quot; pool-size=&quot;20&quot; x=&quot;0&quot; y=&quot;0&quot; /&gt;

    &lt;!-- Wave timer --&gt;
    &lt;qg:timer id=&quot;waveTimer&quot; interval=&quot;8&quot; action=&quot;spawnWave&quot; auto-start=&quot;true&quot; /&gt;

    &lt;!-- Game functions --&gt;
    &lt;q:function name=&quot;spawnWave&quot;&gt;
      &lt;q:set name=&quot;waveNumber&quot; value=&quot;{waveNumber + 1}&quot; /&gt;
      &lt;q:set name=&quot;enemiesPerWave&quot; value=&quot;{5 + waveNumber * 2}&quot; /&gt;
      var count = game.getVar(&#x27;enemiesPerWave&#x27;);
      for (var i = 0; i &amp;lt; count; i++) {
        game.scheduleOnce(i * 0.6, function() {
          game.spawn(&#x27;enemySpawner&#x27;);
        });
      }
    &lt;/q:function&gt;

    &lt;q:function name=&quot;placeTower&quot;&gt;
      var cost = game.getVar(&#x27;towerCost&#x27;);
      var g = game.getVar(&#x27;gold&#x27;);
      if (g &amp;lt; cost) return;
      game.addVar(&#x27;gold&#x27;, -cost);
      var slot = game.clickedSprite;
      game.createSprite({
        src: &#x27;assets/tower.png&#x27;,
        x: slot.x, y: slot.y,
        width: 48, height: 48,
        body: &#x27;static&#x27;, tag: &#x27;tower&#x27;
      });
      var towers = game.findByTag(&#x27;tower&#x27;);
      var t = towers[towers.length - 1];
      game.attachBehavior(t, &#x27;Tower&#x27;);
      game.removeClickable(slot);
      game.play(&#x27;buildSound&#x27;);
    &lt;/q:function&gt;

    &lt;!-- Sounds --&gt;
    &lt;qg:sound id=&quot;shootSound&quot; src=&quot;assets/shoot.wav&quot; trigger=&quot;manual&quot; /&gt;
    &lt;qg:sound id=&quot;killSound&quot;  src=&quot;assets/kill.wav&quot;  trigger=&quot;manual&quot; /&gt;
    &lt;qg:sound id=&quot;buildSound&quot; src=&quot;assets/build.wav&quot; trigger=&quot;manual&quot; /&gt;

    &lt;!-- HUD --&gt;
    &lt;qg:hud position=&quot;top-left&quot;&gt;
      &lt;text style=&quot;color:#FFD700;font-size:18px;font-weight:bold;&quot;&gt;Gold: {gold}&lt;/text&gt;
      &lt;text style=&quot;color:#FF4444;font-size:18px;margin-left:20px;&quot;&gt;Lives: {lives}&lt;/text&gt;
      &lt;text style=&quot;color:#FFFFFF;font-size:18px;margin-left:20px;&quot;&gt;Wave: {waveNumber}&lt;/text&gt;
    &lt;/qg:hud&gt;

    &lt;qg:hud position=&quot;bottom-center&quot;&gt;
      &lt;text style=&quot;color:#AAAAAA;font-size:14px;&quot;&gt;Click green slots to place towers ({towerCost}g)&lt;/text&gt;
    &lt;/qg:hud&gt;

  &lt;/qg:scene&gt;

&lt;/q:application&gt;
</pre>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20/build/matter.min.js"></script>
  <script>
function toggleSource() {
  var modal = document.getElementById('qg-source-modal');
  modal.classList.toggle('visible');
}
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    document.getElementById('qg-source-modal').classList.remove('visible');
  }
});
(async function() {

  // === PIXI APP ===
  const app = new PIXI.Application();
  await app.init({ width: 800, height: 600, background: "#2d5a1e" });
  document.body.appendChild(app.canvas);

  // === MATTER.JS ENGINE ===
  const mEngine = Matter.Engine.create();
  mEngine.gravity.x = 0;
  mEngine.gravity.y = 0;
  const mWorld = mEngine.world;

  // === EVENT BUS ===
  // Event Bus
  const _gameEvents = { _listeners: {} };
  _gameEvents.on = function(event, cb) {
    if (!this._listeners[event]) {
      this._listeners[event] = [];
    }
    this._listeners[event].push(cb);
  };
  _gameEvents.off = function(event, cb) {
    if (this._listeners[event]) {
      this._listeners[event] = this._listeners[event].filter(fn => fn !== cb);
    }
  };
  _gameEvents.emit = function(event, data) {
    if (this._listeners[event]) {
      for (const cb of this._listeners[event]) {
        cb(data);
      }
    }
  };

  // === GAME STATE ===
  let gold = 100;
  let lives = 20;
  let waveNumber = 0;
  let towerCost = 25;
  let enemiesPerWave = 5;
  let waveActive = false;
  let pathX = "[0,200,200,600,600,800]";
  let pathY = "[300,300,150,150,450,450]";

  // === ASSET LOADING ===
  await PIXI.Assets.load(["assets/build.wav", "assets/kill.wav", "assets/shoot.wav"]);

  // === ANIMATION SYSTEM ===
  // Animation System
  const _animatedSprites = {};

  function _parseFrames(spec) {
    if (spec.includes('-')) {
      const parts = spec.split('-').map(Number);
      const result = [];
      for (let i = parts[0]; i <= parts[1]; i += 1) {
        result.push(i);
      }
      return result;
    }
    return spec.split(',').map(s => parseInt(s.trim(), 10));
  }

  function _registerAnimation(spriteId, texture, frameW, frameH, anims) {
    if (!texture || !frameW || !frameH) {
      return;
    }
    const baseTexture = texture.source || texture.baseTexture || texture;
    const texW = baseTexture.width || texture.width;
    const texH = baseTexture.height || texture.height;
    const cols = Math.floor(texW / frameW);
    const rows = Math.floor(texH / frameH);
    const totalFrames = cols * rows;

    // Build frame textures
    const frameTextures = [];
    for (let i = 0; i <= totalFrames - 1; i += 1) {
      const fx = i % cols;
      const fy = Math.floor(i / cols);
      const rect = new PIXI.Rectangle(fx * frameW, fy * frameH, frameW, frameH);
      const frameTex = new PIXI.Texture({ source: baseTexture, frame: rect });
      frameTextures.push(frameTex);
    }

    // Parse named animations
    const animDefs = {};
    let defaultAnim = null;
    for (const [name, cfg] of Object.entries(anims)) {
      const frames = _parseFrames(cfg.frames);
      const textures = frames.filter(f => f < frameTextures.length).map(f => frameTextures[f]);
      if (textures.length > 0) {
        animDefs[name] = { textures: textures, speed: cfg.speed || 0.1, loop: cfg.loop !== false };
        if (cfg.autoPlay) {
          defaultAnim = name;
        }
      }
    }

    if (Object.keys(animDefs).length === 0) {
      return;
    }

    if (!defaultAnim) {
      defaultAnim = Object.keys(animDefs)[0];
    }

    // Create animated sprite
    const firstAnim = animDefs[defaultAnim];
    const animSprite = new PIXI.AnimatedSprite(firstAnim.textures);
    animSprite.animationSpeed = firstAnim.speed;
    if (firstAnim.loop !== false) {
      animSprite.loop = true;
    }
    animSprite.play();

    // Copy transform from static sprite
    const info = _sprites[spriteId];
    if (info) {
      const oldSprite = info.sprite;
      animSprite.x = oldSprite.x;
      animSprite.y = oldSprite.y;
      animSprite.anchor.x = oldSprite.anchor ? oldSprite.anchor.x : 0.5;
      animSprite.anchor.y = oldSprite.anchor ? oldSprite.anchor.y : 0.5;
      if (oldSprite.width) {
        animSprite.width = oldSprite.width;
      }
      if (oldSprite.height) {
        animSprite.height = oldSprite.height;
      }
      animSprite.alpha = oldSprite.alpha;
      animSprite.visible = oldSprite.visible;

      // Replace in container
      const parent = oldSprite.parent;
      if (parent) {
        const idx = parent.getChildIndex(oldSprite);
        parent.removeChild(oldSprite);
        parent.addChildAt(animSprite, idx);
      }
      info.sprite = animSprite;
      _animatedSprites[spriteId] = { anims: animDefs, current: defaultAnim, sprite: animSprite };
    }
  }

  function _switchAnimation(spriteId, animName) {
    const entry = _animatedSprites[spriteId];
    if (!entry || entry.current === animName || !entry.anims[animName]) {
      return;
    }
    const anim = entry.anims[animName];
    entry.sprite.textures = anim.textures;
    entry.sprite.animationSpeed = anim.speed;
    entry.sprite.loop = anim.loop !== false;
    entry.sprite.gotoAndPlay(0);
    entry.current = animName;
  }

  function _updateControlAnimations() {
    for (const [spriteId, ctrl] of Object.entries(_controlledSprites)) {
      const entry = _animatedSprites[spriteId];
      if (!entry) {
        continue;
      }
      const info = _sprites[spriteId];
      if (!info || !info.body) {
        continue;
      }
      const vx = Math.abs(info.body.velocity.x);
      const vy = info.body.velocity.y;

      // Priority: jump > walk > idle
      if (Math.abs(vy) > 1 && entry.anims['jump']) {
        _switchAnimation(spriteId, 'jump');
      } else if (vx > 0.5 && _keys[ctrl.right] && entry.anims['walk-right']) {
        _switchAnimation(spriteId, 'walk-right');
      } else if (vx > 0.5 && _keys[ctrl.left] && entry.anims['walk-left']) {
        _switchAnimation(spriteId, 'walk-left');
      } else if (vx > 0.5 && (entry.anims['walk'] || entry.anims['walk-right'])) {
        _switchAnimation(spriteId, entry.anims['walk'] ? 'walk' : 'walk-right');
      } else if (entry.anims['idle']) {
        _switchAnimation(spriteId, 'idle');
      }
    }
  }

  // === BEHAVIORS ===
  // no behaviors

  // === CAMERA ===
  const _cameraContainer = new PIXI.Container();
  app.stage.addChild(_cameraContainer);
  function updateCamera() {
  }

  // === SPRITES & BODIES ===
  const _sprites = {};
  const _bodyToSprite = {};
  const _spr_path0 = new PIXI.Graphics();
  _spr_path0.rect(-112.5, -25.0, 225.0, 50.0);
  _spr_path0.fill({ color: 0x8B7355 });
  _spr_path0.x = 0;
  _spr_path0.y = 275;
  _cameraContainer.addChild(_spr_path0);
  const _body_path0 = Matter.Bodies.rectangle(0, 275, 225, 50, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_path0.id] = "path0";
  _sprites["path0"] = { sprite: _spr_path0, body: _body_path0, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr_path1 = new PIXI.Graphics();
  _spr_path1.rect(-25.0, -87.5, 50.0, 175.0);
  _spr_path1.fill({ color: 0x8B7355 });
  _spr_path1.x = 175;
  _spr_path1.y = 150;
  _cameraContainer.addChild(_spr_path1);
  const _body_path1 = Matter.Bodies.rectangle(175, 150, 50, 175, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_path1.id] = "path1";
  _sprites["path1"] = { sprite: _spr_path1, body: _body_path1, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr_path2 = new PIXI.Graphics();
  _spr_path2.rect(-212.5, -25.0, 425.0, 50.0);
  _spr_path2.fill({ color: 0x8B7355 });
  _spr_path2.x = 200;
  _spr_path2.y = 125;
  _cameraContainer.addChild(_spr_path2);
  const _body_path2 = Matter.Bodies.rectangle(200, 125, 425, 50, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_path2.id] = "path2";
  _sprites["path2"] = { sprite: _spr_path2, body: _body_path2, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr_path3 = new PIXI.Graphics();
  _spr_path3.rect(-25.0, -162.5, 50.0, 325.0);
  _spr_path3.fill({ color: 0x8B7355 });
  _spr_path3.x = 575;
  _spr_path3.y = 150;
  _cameraContainer.addChild(_spr_path3);
  const _body_path3 = Matter.Bodies.rectangle(575, 150, 50, 325, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_path3.id] = "path3";
  _sprites["path3"] = { sprite: _spr_path3, body: _body_path3, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr_path4 = new PIXI.Graphics();
  _spr_path4.rect(-100.0, -25.0, 200.0, 50.0);
  _spr_path4.fill({ color: 0x8B7355 });
  _spr_path4.x = 600;
  _spr_path4.y = 425;
  _cameraContainer.addChild(_spr_path4);
  const _body_path4 = Matter.Bodies.rectangle(600, 425, 200, 50, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_path4.id] = "path4";
  _sprites["path4"] = { sprite: _spr_path4, body: _body_path4, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr_slot0 = new PIXI.Graphics();
  _spr_slot0.rect(-24.0, -24.0, 48.0, 48.0);
  _spr_slot0.fill({ color: 0x4ade80 });
  _spr_slot0.x = 100;
  _spr_slot0.y = 400;
  _cameraContainer.addChild(_spr_slot0);
  const _body_slot0 = Matter.Bodies.rectangle(100, 400, 48, 48, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_slot0.id] = "slot0";
  _spr_slot0.eventMode = 'static';
  _spr_slot0.cursor = "crosshair";
  _spr_slot0.on('pointerdown', (e) => {
    if (typeof placeTower === 'function') {
      placeTower(_sprites["slot0"], e);
    }
  });
  _sprites["slot0"] = { sprite: _spr_slot0, body: _body_slot0, tag: "slot", collisionHandlers: [], behaviors: [] };

  const _spr_slot1 = new PIXI.Graphics();
  _spr_slot1.rect(-24.0, -24.0, 48.0, 48.0);
  _spr_slot1.fill({ color: 0x4ade80 });
  _spr_slot1.x = 300;
  _spr_slot1.y = 80;
  _cameraContainer.addChild(_spr_slot1);
  const _body_slot1 = Matter.Bodies.rectangle(300, 80, 48, 48, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_slot1.id] = "slot1";
  _spr_slot1.eventMode = 'static';
  _spr_slot1.cursor = "crosshair";
  _spr_slot1.on('pointerdown', (e) => {
    if (typeof placeTower === 'function') {
      placeTower(_sprites["slot1"], e);
    }
  });
  _sprites["slot1"] = { sprite: _spr_slot1, body: _body_slot1, tag: "slot", collisionHandlers: [], behaviors: [] };

  const _spr_slot2 = new PIXI.Graphics();
  _spr_slot2.rect(-24.0, -24.0, 48.0, 48.0);
  _spr_slot2.fill({ color: 0x4ade80 });
  _spr_slot2.x = 400;
  _spr_slot2.y = 80;
  _cameraContainer.addChild(_spr_slot2);
  const _body_slot2 = Matter.Bodies.rectangle(400, 80, 48, 48, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_slot2.id] = "slot2";
  _spr_slot2.eventMode = 'static';
  _spr_slot2.cursor = "crosshair";
  _spr_slot2.on('pointerdown', (e) => {
    if (typeof placeTower === 'function') {
      placeTower(_sprites["slot2"], e);
    }
  });
  _sprites["slot2"] = { sprite: _spr_slot2, body: _body_slot2, tag: "slot", collisionHandlers: [], behaviors: [] };

  const _spr_slot3 = new PIXI.Graphics();
  _spr_slot3.rect(-24.0, -24.0, 48.0, 48.0);
  _spr_slot3.fill({ color: 0x4ade80 });
  _spr_slot3.x = 500;
  _spr_slot3.y = 200;
  _cameraContainer.addChild(_spr_slot3);
  const _body_slot3 = Matter.Bodies.rectangle(500, 200, 48, 48, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_slot3.id] = "slot3";
  _spr_slot3.eventMode = 'static';
  _spr_slot3.cursor = "crosshair";
  _spr_slot3.on('pointerdown', (e) => {
    if (typeof placeTower === 'function') {
      placeTower(_sprites["slot3"], e);
    }
  });
  _sprites["slot3"] = { sprite: _spr_slot3, body: _body_slot3, tag: "slot", collisionHandlers: [], behaviors: [] };

  const _spr_slot4 = new PIXI.Graphics();
  _spr_slot4.rect(-24.0, -24.0, 48.0, 48.0);
  _spr_slot4.fill({ color: 0x4ade80 });
  _spr_slot4.x = 500;
  _spr_slot4.y = 500;
  _cameraContainer.addChild(_spr_slot4);
  const _body_slot4 = Matter.Bodies.rectangle(500, 500, 48, 48, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_slot4.id] = "slot4";
  _spr_slot4.eventMode = 'static';
  _spr_slot4.cursor = "crosshair";
  _spr_slot4.on('pointerdown', (e) => {
    if (typeof placeTower === 'function') {
      placeTower(_sprites["slot4"], e);
    }
  });
  _sprites["slot4"] = { sprite: _spr_slot4, body: _body_slot4, tag: "slot", collisionHandlers: [], behaviors: [] };

  const _spr_slot5 = new PIXI.Graphics();
  _spr_slot5.rect(-24.0, -24.0, 48.0, 48.0);
  _spr_slot5.fill({ color: 0x4ade80 });
  _spr_slot5.x = 700;
  _spr_slot5.y = 350;
  _cameraContainer.addChild(_spr_slot5);
  const _body_slot5 = Matter.Bodies.rectangle(700, 350, 48, 48, { isStatic: true, restitution: 0.1, friction: 0.1 });
  _bodyToSprite[_body_slot5.id] = "slot5";
  _spr_slot5.eventMode = 'static';
  _spr_slot5.cursor = "crosshair";
  _spr_slot5.on('pointerdown', (e) => {
    if (typeof placeTower === 'function') {
      placeTower(_sprites["slot5"], e);
    }
  });
  _sprites["slot5"] = { sprite: _spr_slot5, body: _body_slot5, tag: "slot", collisionHandlers: [], behaviors: [] };

  Matter.Composite.add(mWorld, [_body_path0, _body_path1, _body_path2, _body_path3, _body_path4, _body_slot0, _body_slot1, _body_slot2, _body_slot3, _body_slot4, _body_slot5]);

  function syncPhysics() {
    for (const [id, info] of Object.entries(_sprites)) {
      if (info.body && !info.body.isStatic) {
        info.sprite.x = info.body.position.x;
        info.sprite.y = info.body.position.y;
        info.sprite.rotation = info.body.angle;
      }
    }
  }

  // === GAME API ===
  // Game API
  const game = { camera: {} };

  game.destroy = function(info) {
    if (!info) {
      return;
    }
    // Find sprite id
    let spriteId = null;
    for (const [id, entry] of Object.entries(_sprites)) {
      if (entry === info || entry.sprite === info) {
        spriteId = id;
        break;
      }
    }
    if (!spriteId) {
      return;
    }
    const entry = _sprites[spriteId];
    if (entry.sprite && entry.sprite.parent) {
      entry.sprite.parent.removeChild(entry.sprite);
    }
    if (entry.body) {
      Matter.Composite.remove(mWorld, entry.body);
    }
    delete _sprites[spriteId];
  };

  game.play = function(soundId, opts) {
    if (typeof _playSound === 'function') {
      return _playSound(soundId, opts);
    }
  };

  game.emit = function(info, event) {
    _gameEvents.emit(event, info);
    if (info && info.tag) {
      _gameEvents.emit(info.tag + '.' + event, info);
    }
  };

  game.loadScene = function(name) {
    if (typeof _loadScene === 'function') {
      _loadScene(name);
    }
  };

  game.respawn = function(id, x, y) {
    const info = _sprites[id];
    if (!info) {
      return;
    }
    if (info.sprite) {
      info.sprite.x = x;
      info.sprite.y = y;
      info.sprite.visible = true;
    }
    if (info.body) {
      Matter.Body.setPosition(info.body, { x: x, y: y });
      Matter.Body.setVelocity(info.body, { x: 0, y: 0 });
    }
  };

  game.destroyGroup = function(groupName) {
    const toRemove = [];
    for (const [id, info] of Object.entries(_sprites)) {
      if (info.group === groupName) {
        toRemove.push(info);
      }
    }
    for (const info of toRemove) {
      game.destroy(info);
    }
  };

  game.moveX = function(info, dx) {
    if (info && info.body) {
      Matter.Body.setVelocity(info.body, { x: dx, y: info.body.velocity.y });
    }
  };

  game.moveToward = function(info, targetId, speed) {
    if (!info || !info.body) {
      return;
    }
    const target = _sprites[targetId];
    if (!target) {
      return;
    }
    const dx = target.sprite.x - info.sprite.x;
    const dy = target.sprite.y - info.sprite.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 1) {
      return;
    }
    Matter.Body.setVelocity(info.body, { x: (dx / dist) * speed, y: (dy / dist) * speed });
  };

  game.patrol = function(info, speed) {
    game.moveX(info, speed);
  };

  game.camera.shake = function(intensity, duration) {
    let _shakeFrames = Math.floor((duration || 0.3) * 60);
    const _shakeIntensity = intensity || 5;
    const origX = _cameraContainer.x;
    const origY = _cameraContainer.y;
    const _shakeTick = () => {
      if (_shakeFrames <= 0) {
        _cameraContainer.x = origX;
        _cameraContainer.y = origY;
        return;
      }
      _cameraContainer.x = origX + (Math.random() - 0.5) * _shakeIntensity * 2;
      _cameraContainer.y = origY + (Math.random() - 0.5) * _shakeIntensity * 2;
      _shakeFrames--;
      requestAnimationFrame(_shakeTick);
    };
    _shakeTick();
  };

  game.spawn = function(id) {
    if (typeof _spawn === 'function') {
      _spawn(id);
    }
  };

  // === BEHAVIOR ATTACHMENTS ===
  // no behavior attachments
  // Init state machines
  for (const [_id, _info] of Object.entries(_sprites)) {
    for (const b of _info.behaviors) {
      if (b._smInit) {
        b._smInit();
      }
    }
  }

  // === ANIMATION REGISTRATION ===
  // no animations to register

  // === INPUT ===
  const _keys = {};
  const _justPressed = {};
  window.addEventListener('keydown', (e) => {
    if (!_keys[e.key]) _justPressed[e.key] = true;
    _keys[e.key] = true;
  });
  window.addEventListener('keyup', (e) => {
    _keys[e.key] = false;
  });
  function _clearJustPressed() {
    for (const k in _justPressed) delete _justPressed[k];
  }
  const _controlledSprites = {};

  // === MOUSE ===
  // Mouse System
  let _mouseX = 0;
  let _mouseY = 0;
  let _mouseWorldX = 0;
  let _mouseWorldY = 0;
  app.canvas.addEventListener('pointermove', (e) => {
    const rect = app.canvas.getBoundingClientRect();
    _mouseX = e.clientX - rect.left;
    _mouseY = e.clientY - rect.top;
    // Convert to world coordinates (accounting for camera)
    _mouseWorldX = _mouseX - _cameraContainer.x;
    _mouseWorldY = _mouseY - _cameraContainer.y;
  });

  // === FUNCTIONS ===
  function spawnWave() {
    waveNumber = waveNumber + 1;
    enemiesPerWave = 5 + waveNumber * 2;
    var count = game.getVar('enemiesPerWave');
    for (var i = 0; i < count; i++) {
    game.scheduleOnce(i * 0.6, function() {
    game.spawn('enemySpawner');
    });
    }
  }

  function placeTower() {
    var cost = game.getVar('towerCost');
    var g = game.getVar('gold');
    if (g < cost) return;
    game.addVar('gold', -cost);
    var slot = game.clickedSprite;
    game.createSprite({
    src: 'assets/tower.png',
    x: slot.x, y: slot.y,
    width: 48, height: 48,
    body: 'static', tag: 'tower'
    });
    var towers = game.findByTag('tower');
    var t = towers[towers.length - 1];
    game.attachBehavior(t, 'Tower');
    game.removeClickable(slot);
    game.play('buildSound');
  }


  // === COLLISIONS ===
  // no collision handlers

  // === SOUNDS ===
  // Audio System
  const _sounds = {};
  let _audioCtx = null;
  let _audioUnlocked = false;
  const _pendingSounds = [];

  function _initAudio() {
    if (_audioCtx) {
      return;
    }
    _audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Unlock audio on any user interaction
    const unlockEvents = ['click', 'keydown', 'touchstart', 'pointerdown'];
    function _unlock() {
      if (_audioUnlocked) {
        return;
      }
      if (_audioCtx.state === 'suspended') {
        _audioCtx.resume().then(() => {
          _audioUnlocked = true;
          // Play any queued sounds
          while (_pendingSounds.length > 0) {
            const pending = _pendingSounds.shift();
            _doPlaySound(pending.id, pending.opts);
          }
        });
      } else {
        _audioUnlocked = true;
      }
      for (const evt of unlockEvents) {
        document.removeEventListener(evt, _unlock);
      }
    }

    for (const evt of unlockEvents) {
      document.addEventListener(evt, _unlock, { once: false });
    }
  }

  async function _loadSound(id, url) {
    _initAudio();
    try {
      const resp = await fetch(url);
      const buf = await resp.arrayBuffer();
      _sounds[id] = await _audioCtx.decodeAudioData(buf);
    }
    catch(e) {
      console.warn('Sound load failed:', id, e);
    }
  }

  function _doPlaySound(id, opts) {
    opts = opts || {};
    const buf = _sounds[id];
    if (!buf) {
      return;
    }
    const src = _audioCtx.createBufferSource();
    src.buffer = buf;
    const gain = _audioCtx.createGain();
    gain.gain.value = opts.volume !== undefined ? opts.volume : 1;
    src.connect(gain).connect(_audioCtx.destination);
    src.loop = !!opts.loop;
    src.start(0);
    return src;
  }

  function _playSound(id, opts) {
    if (!_audioUnlocked) {
      _pendingSounds.push({ id: id, opts: opts });
      return;
    }
    return _doPlaySound(id, opts);
  }
  await _loadSound("shootSound", "assets/shoot.wav");
  await _loadSound("killSound", "assets/kill.wav");
  await _loadSound("buildSound", "assets/build.wav");

  // === PARTICLES ===
  // Particle System
  const _particleSystems = {};

  function _createParticleSystem(config) {
    const ps = {
      id: config.id,
      follow: config.follow || null,
      trigger: config.trigger || null,
      count: config.count || 20,
      emitRate: config.emitRate || 10,
      lifetime: config.lifetime || 1,
      speedMin: config.speedMin || 1,
      speedMax: config.speedMax || 3,
      angleMin: (config.angleMin || 0) * Math.PI / 180,
      angleMax: (config.angleMax || 360) * Math.PI / 180,
      alphaStart: config.alphaStart !== undefined ? config.alphaStart : 1,
      alphaEnd: config.alphaEnd !== undefined ? config.alphaEnd : 0,
      active: false,
      emitTimer: 0,
      pool: [],
      container: new PIXI.Container(),
    };

    // Pre-allocate particle pool
    for (let i = 0; i <= ps.count - 1; i += 1) {
      const p = new PIXI.Graphics();
      p.circle(0, 0, 3);
      p.fill({ color: 0xffffff });
      p.visible = false;
      p._life = 0; p._maxLife = 0; p._vx = 0; p._vy = 0;
      p._alphaStart = 1; p._alphaEnd = 0;
      ps.container.addChild(p);
      ps.pool.push(p);
    }

    _cameraContainer.addChild(ps.container);
    _particleSystems[config.id] = ps;
    return ps;
  }

  function _emitParticle(ps, x, y) {
    for (const p of ps.pool) {
      if (!p.visible) {
        p.x = x;
        p.y = y;
        const angle = ps.angleMin + Math.random() * (ps.angleMax - ps.angleMin);
        const speed = ps.speedMin + Math.random() * (ps.speedMax - ps.speedMin);
        p._vx = Math.cos(angle) * speed;
        p._vy = Math.sin(angle) * speed;
        p._life = 0;
        p._maxLife = ps.lifetime;
        p._alphaStart = ps.alphaStart;
        p._alphaEnd = ps.alphaEnd;
        p.alpha = ps.alphaStart;
        p.visible = true;
        return;
      }
    }
  }

  function _activateParticles(psId) {
    const ps = _particleSystems[psId];
    if (ps) {
      ps.active = true;
    }
  }

  function _deactivateParticles(psId) {
    const ps = _particleSystems[psId];
    if (ps) {
      ps.active = false;
    }
  }

  function _updateParticles(dt) {
    for (const [id, ps] of Object.entries(_particleSystems)) {
      // Emit new particles if active
      if (ps.active) {
        ps.emitTimer += dt / 60;
        const interval = 1 / ps.emitRate;
        while (ps.emitTimer >= interval) {
          ps.emitTimer -= interval;
          let ex = 0;
          let ey = 0;
          if (ps.follow) {
            const info = _sprites[ps.follow];
            if (info) {
              ex = info.sprite.x;
              ey = info.sprite.y;
            }
          }
          _emitParticle(ps, ex, ey);
        }
      }

      // Update living particles
      for (const p of ps.pool) {
        if (!p.visible) {
          continue;
        }
        p._life += dt / 60;
        if (p._life >= p._maxLife) {
          p.visible = false;
          continue;
        }
        const lifeT = p._life / p._maxLife;
        p.x = p.x + p._vx;
        p.y = p.y + p._vy;
        p.alpha = p._alphaStart + (p._alphaEnd - p._alphaStart) * lifeT;
      }
    }
  }
  // No particle instances

  // === TIMERS ===
  // Timer System
  const _timers = {};
  const _timerActions = {};

  function _createTimer(id, interval, repeat, autoStart, actionFn) {
    _timers[id] = { elapsed: 0, interval: interval, repeat: repeat, count: 0, active: autoStart };
    _timerActions[id] = actionFn;
  }

  function _updateTimers(dt) {
    for (const [tid, t] of Object.entries(_timers)) {
      if (!t.active) {
        continue;
      }
      t.elapsed += dt / 60;
      if (t.elapsed >= t.interval) {
        t.elapsed = 0;
        if (_timerActions[tid]) {
          _timerActions[tid]();
        }
        t.count++;
        if (t.repeat >= 0 && t.count >= t.repeat) {
          t.active = false;
        }
      }
    }
  }
  _createTimer("waveTimer", 8, -1, true, typeof spawnWave === 'function' ? spawnWave : function(){});

  // === TWEENS ===
  // Easing Functions
  const _easing = {
    linear: t => t,
    easeIn: t => t * t,
    easeOut: t => t * (2 - t),
    easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    easeInCubic: t => t * t * t,
    easeOutCubic: t => (--t) * t * t + 1,
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    easeInQuart: t => t * t * t * t,
    easeOutQuart: t => 1 - (--t) * t * t * t,
    easeInOutQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,
    easeOutBounce: t => {
      if (t < 1/2.75) return 7.5625 * t * t;
      if (t < 2/2.75) return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
      if (t < 2.5/2.75) return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
      return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
    },
    easeInBounce: t => 1 - _easing.easeOutBounce(1 - t),
    easeOutElastic: t => {
      if (t === 0 || t === 1) return t;
      return Math.pow(2, -10 * t) * Math.sin((t - 0.075) * (2 * Math.PI) / 0.3) + 1;
    },
    easeInElastic: t => {
      if (t === 0 || t === 1) return t;
      return -Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.075) * (2 * Math.PI) / 0.3);
    },
  };

  const _tweens = {};
  let _tweenIdCounter = 0;

  function _createTween(config) {
    const id = config.id || ('tween_' + _tweenIdCounter++);
    _tweens[id] = {
      target: config.target,
      prop: config.prop,
      from: null,
      to: config.to,
      duration: config.duration || 1,
      easing: config.easing || 'linear',
      loop: !!config.loop,
      yoyo: !!config.yoyo,
      delay: config.delay || 0,
      elapsed: 0,
      delayElapsed: 0,
      active: config.active !== false,
      started: false,
    };
    return id;
  }

  function _updateTweens(dt) {
    for (const [tid, tw] of Object.entries(_tweens)) {
      if (!tw.active) {
        continue;
      }
      // Handle delay
      if (tw.delayElapsed < tw.delay) {
        tw.delayElapsed += dt / 60;
        continue;
      }
      // Init start value on first frame
      if (!tw.started) {
        const info = _sprites[tw.target];
        if (!info) {
          continue;
        }
        tw.from = info.sprite[tw.prop];
        tw.started = true;
      }
      tw.elapsed += dt / 60;
      const rawT = Math.min(tw.elapsed / tw.duration, 1);
      const easeFn = _easing[tw.easing] || _easing.linear;
      const t = easeFn(rawT);
      const info = _sprites[tw.target];
      if (info) {
        info.sprite[tw.prop] = tw.from + (tw.to - tw.from) * t;
      }
      if (rawT >= 1) {
        if (tw.loop) {
          tw.elapsed = 0;
          if (tw.yoyo) {
            const tmp = tw.from;
            tw.from = tw.to;
            tw.to = tmp;
          }
        } else {
          tw.active = false;
        }
      }
    }
  }
  // No tween instances

  // === SPAWNERS ===
  // Spawn System
  const _spawners = {};
  const _prefabConfigs = {};

  function _registerPrefab(name, config) {
    _prefabConfigs[name] = config;
  }

  function _createSpawner(config) {
    _spawners[config.id] = {
      id: config.id,
      prefab: config.prefab,
      poolSize: config.poolSize || 10,
      spawnX: config.x || 0,
      spawnY: config.y || 0,
      interval: config.interval || null,
      pool: [],
      active: 0,
    };
  }

  function _createPrefabSprite(prefabName, x, y) {
    const config = _prefabConfigs[prefabName];
    if (!config) {
      console.warn('Unknown prefab:', prefabName);
      return null;
    }
    const w = config.width || 20;
    const h = config.height || 20;
    const spr = new PIXI.Graphics();
    // Center the rectangle like main sprites
    spr.rect(-w/2, -h/2, w, h);
    if (config.color) {
      spr.fill({ color: parseInt(config.color.replace('#',''), 16) });
    } else {
      spr.fill({ color: 0x22c55e });
    }
    spr.x = x;
    spr.y = y;
    _cameraContainer.addChild(spr);
    return spr;
  }

  function _spawn(spawnerId) {
    const sp = _spawners[spawnerId];
    if (!sp) {
      return null;
    }
    // Find an inactive pool member
    for (const item of sp.pool) {
      if (!item.active) {
        item.active = true;
        if (item.sprite) {
          item.sprite.visible = true;
          item.sprite.x = sp.spawnX;
          item.sprite.y = sp.spawnY;
        }
        if (item.body) {
          Matter.Body.setPosition(item.body, { x: sp.spawnX, y: sp.spawnY });
        }
        return item.sprite;
      }
    }
    // No inactive items, create new if under pool limit
    if (sp.pool.length < sp.poolSize) {
      const newSprite = _createPrefabSprite(sp.prefab, sp.spawnX, sp.spawnY);
      if (newSprite) {
        const newItem = { sprite: newSprite, active: true, body: null };
        sp.pool.push(newItem);
        return newSprite;
      }
    }
    return null;
  }
  _createSpawner({ id: "enemySpawner", prefab: "EnemyPrefab", poolSize: 30, x: 0, y: 300 });
  _createSpawner({ id: "bulletSpawner", prefab: "BulletPrefab", poolSize: 20, x: 0, y: 0 });

  // === VISUAL TILEMAPS ===
  // No visual tile layers

  // === HUD UPDATE ===
  const _hudElements = [];
  _hudElements.push(document.getElementById('qg-hud-0'));
  _hudElements.push(document.getElementById('qg-hud-1'));
  function _updateHUD() {
    if (_hudElements[0]) {
      _hudElements[0].textContent = "Gold: " + String(gold) + "Lives: " + String(lives) + "Wave: " + String(waveNumber);
    }
    if (_hudElements[1]) {
      _hudElements[1].textContent = "Click green slots to place towers (" + String(towerCost) + "g)";
    }
  }

  // === GAME LOOP ===
  app.ticker.add((ticker) => {
    const dt = ticker.deltaTime;
    Matter.Engine.update(mEngine, dt * 16.67);
    syncPhysics();
    // Input handling
    _clearJustPressed();
    updateCamera();
    _updateControlAnimations();
    // Behaviors update
    for (const [_id, _info] of Object.entries(_sprites)) {
      for (const b of _info.behaviors) {
        if (b._smUpdate) {
          b._smUpdate();
        }
        if (b.update) {
          b.update();
        }
      }
    }
    _updateTimers(dt);
    _updateHUD();
  });

  // === SCENE START ===
  _gameEvents.on("manual", () => _playSound("shootSound", { volume: 1, loop: false }));
  _gameEvents.on("manual", () => _playSound("killSound", { volume: 1, loop: false }));
  _gameEvents.on("manual", () => _playSound("buildSound", { volume: 1, loop: false }));
})();
  </script>
</body>
</html>
