<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>18_enemies.q</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #111; display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; }
    canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; transform: scale(3); transform-origin: center center; }
    .qg-hud { position: absolute; pointer-events: none; padding: 8px; font-family: sans-serif; z-index: 10; }
    .qg-hud-top-left { top: 0; left: 0; }
    .qg-hud-top-right { top: 0; right: 0; }
    .qg-hud-top-center { top: 0; left: 50%; transform: translateX(-50%); }
    .qg-hud-bottom-left { bottom: 0; left: 0; }
    .qg-hud-bottom-right { bottom: 0; right: 0; }
    .qg-hud-bottom-center { bottom: 0; left: 50%; transform: translateX(-50%); }
    .qg-hud-center { top: 50%; left: 50%; transform: translate(-50%, -50%); }

    /* Source Code Viewer */
    #qg-source-btn {
      position: fixed;
      bottom: 16px;
      right: 16px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-family: monospace;
      font-size: 12px;
      transition: all 0.2s;
    }
    #qg-source-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.9);
    }
    #qg-source-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.92);
      z-index: 999;
      overflow: auto;
    }
    #qg-source-modal.visible {
      display: flex;
      flex-direction: column;
    }
    #qg-source-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-family: monospace;
      font-size: 13px;
      z-index: 1001;
    }
    #qg-source-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    #qg-source-content {
      flex: 1;
      overflow: auto;
      padding: 48px 24px 24px;
    }
    #qg-source-content pre {
      background: #1e1e2e;
      color: #cdd6f4;
      padding: 24px;
      border-radius: 12px;
      font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      line-height: 1.7;
      overflow-x: auto;
      white-space: pre;
      tab-size: 2;
      border: 1px solid #313244;
      max-width: 900px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div class="qg-hud qg-hud-top-left" id="qg-hud-0"><div style="color: #FFD700; font-family: monospace; font-size: 14px; text-shadow: 1px 1px #000;">
        MARIO x <span id="lives-display">3</span> | COINS: <span id="coin-display">0</span> | SCORE: <span id="score-display">0</span></div></div>
  <div class="qg-hud qg-hud-center" id="qg-hud-1"><div id="game-over" style="display: none; background: rgba(0,0,0,0.9); padding: 20px; text-align: center; color: #fff; font-family: monospace; border-radius: 10px;"><div style="font-size: 18px; color: #FF4444; margin-bottom: 10px;">GAME OVER</div><div style="font-size: 12px; margin-bottom: 10px;">Final Score: <span id="gameover-score">0</span></div><button style="padding: 8px 20px; cursor: pointer; font-size: 14px;">TRY AGAIN</button></div></div>
  <div class="qg-hud qg-hud-center" id="qg-hud-2"><div id="level-complete" style="display: none; background: rgba(0,128,0,0.9); padding: 20px; text-align: center; color: #fff; font-family: monospace; border-radius: 10px;"><div style="font-size: 18px; color: #FFD700; margin-bottom: 10px;">COURSE CLEAR!</div><div style="font-size: 12px; margin-bottom: 10px;">Score: <span id="final-score">0</span></div><button style="padding: 8px 20px; cursor: pointer; font-size: 14px;">PLAY AGAIN</button></div></div>
  <button id="qg-source-btn" onclick="toggleSource()">source</button>
  <div id="qg-source-modal">
    <button id="qg-source-close" onclick="toggleSource()">ESC</button>
    <div id="qg-source-content">
      <pre id="qg-source-code">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--
  Phase 18: Yoshi&#x27;s Island 1 (Full Level)

  Recreation of the first level from SMW with:
  - Full level image as background (5120x432 pixels)
  - Rex enemies (purple dinosaurs)
  - Camera scrolling
  - Stomp mechanic (2 hits to kill Rex)

  Level: 320 tiles wide (5120 pixels)
--&gt;
&lt;q:application id=&quot;yoshi-island-1&quot; type=&quot;game&quot; engine=&quot;2d&quot;&gt;
  &lt;qg:scene name=&quot;main&quot; width=&quot;5120&quot; height=&quot;432&quot; viewport-width=&quot;256&quot; viewport-height=&quot;224&quot; background=&quot;#5C94FC&quot;&gt;
    &lt;qg:physics gravity-y=&quot;1.5&quot; /&gt;
    &lt;qg:camera follow=&quot;mario&quot; lerp=&quot;0.08&quot; bounds=&quot;scene&quot; offset-y=&quot;-80&quot; /&gt;

    &lt;!-- Game state --&gt;
    &lt;q:set name=&quot;coins&quot; value=&quot;0&quot; type=&quot;number&quot; /&gt;
    &lt;q:set name=&quot;score&quot; value=&quot;0&quot; type=&quot;number&quot; /&gt;
    &lt;q:set name=&quot;lives&quot; value=&quot;3&quot; type=&quot;number&quot; /&gt;
    &lt;q:set name=&quot;isDead&quot; value=&quot;0&quot; type=&quot;number&quot; /&gt;

    &lt;!-- Preload textures --&gt;
    &lt;qg:sprite id=&quot;_preload_used&quot; src=&quot;assets/smw/sprites/qblock_used.png&quot;
               x=&quot;-100&quot; y=&quot;-100&quot; width=&quot;16&quot; height=&quot;16&quot; visible=&quot;false&quot; /&gt;
    &lt;qg:sprite id=&quot;_preload_death&quot; src=&quot;assets/smw/sprites/mario_death.png&quot;
               x=&quot;-100&quot; y=&quot;-100&quot; width=&quot;16&quot; height=&quot;16&quot; visible=&quot;false&quot; /&gt;

    &lt;!-- Sound Effects --&gt;
    &lt;qg:sound id=&quot;sfx-jump&quot; src=&quot;assets/smw/sounds/smw_jump.wav&quot; trigger=&quot;player.jump&quot; /&gt;
    &lt;qg:sound id=&quot;sfx-coin&quot; src=&quot;assets/smw/sounds/smw_coin.wav&quot; trigger=&quot;coin-collected&quot; /&gt;
    &lt;qg:sound id=&quot;sfx-stomp&quot; src=&quot;assets/smw/sounds/smw_stomp.wav&quot; trigger=&quot;enemy-stomped&quot; /&gt;
    &lt;qg:sound id=&quot;sfx-death&quot; src=&quot;assets/smw/sounds/smw_lost_a_life.wav&quot; trigger=&quot;mario-died&quot; /&gt;
    &lt;qg:sound id=&quot;sfx-clear&quot; src=&quot;assets/smw/sounds/smw_course_clear.wav&quot; trigger=&quot;level-complete&quot; /&gt;
    &lt;qg:sound id=&quot;sfx-block&quot; src=&quot;assets/smw/sounds/smw_message_block.wav&quot; trigger=&quot;block-hit&quot; /&gt;

    &lt;!-- Background Music --&gt;
    &lt;qg:sound id=&quot;bgm-level&quot; src=&quot;assets/smw/sounds/music/music-map1.wav&quot;
              trigger=&quot;scene.start&quot; loop=&quot;true&quot; volume=&quot;0.5&quot; channel=&quot;music&quot; /&gt;

    &lt;!-- Prefabs --&gt;
    &lt;qg:prefab name=&quot;qblock&quot;&gt;
      &lt;qg:sprite src=&quot;assets/smw/sprites/qblock_animated.png&quot;
                 frame-width=&quot;16&quot; frame-height=&quot;16&quot;
                 tag=&quot;qblock&quot; body=&quot;static&quot;&gt;
        &lt;qg:animation name=&quot;shine&quot; frames=&quot;0,1,2,3&quot; speed=&quot;0.15&quot; loop=&quot;true&quot; auto-play=&quot;true&quot; /&gt;
      &lt;/qg:sprite&gt;
    &lt;/qg:prefab&gt;

    &lt;qg:prefab name=&quot;coin&quot;&gt;
      &lt;qg:sprite src=&quot;assets/smw/sprites/coin_animated.png&quot;
                 frame-width=&quot;16&quot; frame-height=&quot;16&quot;
                 tag=&quot;coin&quot; body=&quot;static&quot; sensor=&quot;true&quot;&gt;
        &lt;qg:animation name=&quot;spin&quot; frames=&quot;0,1,2,3,2,1&quot; speed=&quot;0.12&quot; loop=&quot;true&quot; auto-play=&quot;true&quot; /&gt;
      &lt;/qg:sprite&gt;
    &lt;/qg:prefab&gt;

    &lt;!-- Yoshi coins removed - spritesheet issue --&gt;

    &lt;qg:prefab name=&quot;rex&quot;&gt;
      &lt;qg:sprite src=&quot;assets/smw/sprites/rex_walk.png&quot;
                 frame-width=&quot;12&quot; frame-height=&quot;24&quot;
                 tag=&quot;enemy&quot; body=&quot;dynamic&quot; friction=&quot;0&quot;&gt;
        &lt;qg:animation name=&quot;walk&quot; frames=&quot;0-1&quot; speed=&quot;0.15&quot; loop=&quot;true&quot; auto-play=&quot;true&quot; /&gt;
      &lt;/qg:sprite&gt;
    &lt;/qg:prefab&gt;

    &lt;!-- Full level background image --&gt;
    &lt;qg:sprite id=&quot;level-bg&quot; src=&quot;assets/smw/sprites/yoshi-island-1.png&quot;
               x=&quot;2560&quot; y=&quot;216&quot; width=&quot;5120&quot; height=&quot;432&quot; /&gt;

    &lt;!-- Ground collision - top at y=383 (grass line) --&gt;
    &lt;qg:sprite id=&quot;ground&quot; width=&quot;5120&quot; height=&quot;32&quot; x=&quot;2560&quot; y=&quot;399&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; visible=&quot;false&quot; /&gt;

    &lt;!-- Hill 1 collision (stair steps) - starts at xâ‰ˆ170 DEBUG: green --&gt;
    &lt;qg:sprite id=&quot;hill1-step1&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;190&quot; y=&quot;375&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;qg:sprite id=&quot;hill1-step2&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;230&quot; y=&quot;359&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;qg:sprite id=&quot;hill1-step3&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;270&quot; y=&quot;343&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;qg:sprite id=&quot;hill1-step4&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;310&quot; y=&quot;327&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;qg:sprite id=&quot;hill1-top&quot; width=&quot;60&quot; height=&quot;16&quot; x=&quot;360&quot; y=&quot;311&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;!-- Down slope --&gt;
    &lt;qg:sprite id=&quot;hill1-down1&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;410&quot; y=&quot;327&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;qg:sprite id=&quot;hill1-down2&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;450&quot; y=&quot;343&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;qg:sprite id=&quot;hill1-down3&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;490&quot; y=&quot;359&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;
    &lt;qg:sprite id=&quot;hill1-down4&quot; width=&quot;40&quot; height=&quot;16&quot; x=&quot;530&quot; y=&quot;375&quot;
               tag=&quot;terrain&quot; body=&quot;static&quot; color=&quot;#00FF00&quot; /&gt;

    &lt;!-- Question blocks (matching image positions) --&gt;
    &lt;qg:instance prefab=&quot;qblock&quot; id=&quot;qb1&quot; x=&quot;496&quot; y=&quot;256&quot; /&gt;
    &lt;qg:instance prefab=&quot;qblock&quot; id=&quot;qb2&quot; x=&quot;592&quot; y=&quot;256&quot; /&gt;
    &lt;qg:instance prefab=&quot;qblock&quot; id=&quot;qb3&quot; x=&quot;1040&quot; y=&quot;256&quot; /&gt;
    &lt;qg:instance prefab=&quot;qblock&quot; id=&quot;qb4&quot; x=&quot;3200&quot; y=&quot;192&quot; /&gt;
    &lt;qg:instance prefab=&quot;qblock&quot; id=&quot;qb5&quot; x=&quot;3216&quot; y=&quot;192&quot; /&gt;
    &lt;qg:instance prefab=&quot;qblock&quot; id=&quot;qb6&quot; x=&quot;3232&quot; y=&quot;192&quot; /&gt;
    &lt;qg:instance prefab=&quot;qblock&quot; id=&quot;qb7&quot; x=&quot;3248&quot; y=&quot;192&quot; /&gt;

    &lt;!-- Coins (matching image - floating coins) --&gt;
    &lt;!-- Coins --&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;160&quot; y=&quot;288&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;528&quot; y=&quot;224&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;560&quot; y=&quot;224&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;1600&quot; y=&quot;288&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;2656&quot; y=&quot;176&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;2672&quot; y=&quot;176&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;2688&quot; y=&quot;176&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;2704&quot; y=&quot;176&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;2720&quot; y=&quot;176&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;3600&quot; y=&quot;272&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;3616&quot; y=&quot;272&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;4080&quot; y=&quot;288&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;4096&quot; y=&quot;288&quot; /&gt;
    &lt;qg:instance prefab=&quot;coin&quot; x=&quot;4112&quot; y=&quot;288&quot; /&gt;

    &lt;!-- Rex enemies (ground top at y=383, Rex height=24, center at y=371) --&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex1&quot; x=&quot;450&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex2&quot; x=&quot;700&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex3&quot; x=&quot;950&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex4&quot; x=&quot;1300&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex5&quot; x=&quot;1600&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex6&quot; x=&quot;1900&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex7&quot; x=&quot;2200&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex8&quot; x=&quot;2700&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex9&quot; x=&quot;3100&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex10&quot; x=&quot;3500&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex11&quot; x=&quot;3900&quot; y=&quot;371&quot; /&gt;
    &lt;qg:instance prefab=&quot;rex&quot; id=&quot;rex12&quot; x=&quot;4300&quot; y=&quot;371&quot; /&gt;

    &lt;!-- Goal at the end (visible in image around x=4900) --&gt;
    &lt;qg:sprite id=&quot;goal&quot; width=&quot;16&quot; height=&quot;80&quot; x=&quot;4950&quot; y=&quot;344&quot;
               color=&quot;#00FF00&quot; tag=&quot;goal&quot; body=&quot;static&quot; sensor=&quot;true&quot; /&gt;

    &lt;!-- Mario (ground top at y=383, Mario height=24, center at y=371) --&gt;
    &lt;qg:sprite id=&quot;mario&quot; src=&quot;assets/smw/sprites/mario_small.png&quot;
               x=&quot;80&quot; y=&quot;371&quot; tag=&quot;player&quot;
               frame-width=&quot;16&quot; frame-height=&quot;24&quot;
               body=&quot;dynamic&quot; controls=&quot;arrows&quot; speed=&quot;2&quot; jump-force=&quot;5.5&quot; friction=&quot;0.1&quot;&gt;
      &lt;qg:animation name=&quot;idle&quot; frames=&quot;0&quot; speed=&quot;0.1&quot; loop=&quot;true&quot; auto-play=&quot;true&quot; /&gt;
      &lt;qg:animation name=&quot;walk&quot; frames=&quot;1-3&quot; speed=&quot;0.18&quot; loop=&quot;true&quot; /&gt;
      &lt;qg:animation name=&quot;jump&quot; frames=&quot;4&quot; speed=&quot;0.1&quot; loop=&quot;false&quot; /&gt;
      &lt;qg:on-collision with-tag=&quot;coin&quot; action=&quot;emit:coin-collected&quot; /&gt;
      &lt;qg:on-collision with-tag=&quot;coin&quot; action=&quot;destroy-other&quot; /&gt;
      &lt;qg:on-collision with-tag=&quot;qblock&quot; action=&quot;emit:block-hit&quot; /&gt;
      &lt;qg:on-collision with-tag=&quot;enemy&quot; action=&quot;emit:enemy-collision&quot; /&gt;
      &lt;qg:on-collision with-tag=&quot;death&quot; action=&quot;emit:fell-in-pit&quot; /&gt;
      &lt;qg:on-collision with-tag=&quot;goal&quot; action=&quot;emit:level-complete&quot; /&gt;
    &lt;/qg:sprite&gt;

    &lt;!-- HUD --&gt;
    &lt;qg:hud position=&quot;top-left&quot;&gt;
      &lt;div style=&quot;color: #FFD700; font-family: monospace; font-size: 14px; text-shadow: 1px 1px #000;&quot;&gt;
        MARIO x &lt;span id=&quot;lives-display&quot;&gt;3&lt;/span&gt; | COINS: &lt;span id=&quot;coin-display&quot;&gt;0&lt;/span&gt; | SCORE: &lt;span id=&quot;score-display&quot;&gt;0&lt;/span&gt;
      &lt;/div&gt;
    &lt;/qg:hud&gt;

    &lt;qg:hud position=&quot;center&quot;&gt;
      &lt;div id=&quot;game-over&quot; style=&quot;display: none; background: rgba(0,0,0,0.9); padding: 20px; text-align: center; color: #fff; font-family: monospace; border-radius: 10px;&quot;&gt;
        &lt;div style=&quot;font-size: 18px; color: #FF4444; margin-bottom: 10px;&quot;&gt;GAME OVER&lt;/div&gt;
        &lt;div style=&quot;font-size: 12px; margin-bottom: 10px;&quot;&gt;Final Score: &lt;span id=&quot;gameover-score&quot;&gt;0&lt;/span&gt;&lt;/div&gt;
        &lt;button onclick=&quot;location.reload()&quot; style=&quot;padding: 8px 20px; cursor: pointer; font-size: 14px;&quot;&gt;TRY AGAIN&lt;/button&gt;
      &lt;/div&gt;
    &lt;/qg:hud&gt;

    &lt;qg:hud position=&quot;center&quot;&gt;
      &lt;div id=&quot;level-complete&quot; style=&quot;display: none; background: rgba(0,128,0,0.9); padding: 20px; text-align: center; color: #fff; font-family: monospace; border-radius: 10px;&quot;&gt;
        &lt;div style=&quot;font-size: 18px; color: #FFD700; margin-bottom: 10px;&quot;&gt;COURSE CLEAR!&lt;/div&gt;
        &lt;div style=&quot;font-size: 12px; margin-bottom: 10px;&quot;&gt;Score: &lt;span id=&quot;final-score&quot;&gt;0&lt;/span&gt;&lt;/div&gt;
        &lt;button onclick=&quot;location.reload()&quot; style=&quot;padding: 8px 20px; cursor: pointer; font-size: 14px;&quot;&gt;PLAY AGAIN&lt;/button&gt;
      &lt;/div&gt;
    &lt;/qg:hud&gt;

    &lt;!-- Death zone at bottom (below visible area) --&gt;
    &lt;qg:sprite id=&quot;deathzone&quot; width=&quot;5120&quot; height=&quot;16&quot; x=&quot;2560&quot; y=&quot;480&quot;
               tag=&quot;death&quot; body=&quot;static&quot; sensor=&quot;true&quot; visible=&quot;false&quot; /&gt;

    &lt;!-- Events --&gt;
    &lt;qg:event name=&quot;coin-collected&quot; handler=&quot;onCoinCollected&quot; /&gt;
    &lt;qg:event name=&quot;block-hit&quot; handler=&quot;onBlockHit&quot; /&gt;
    &lt;qg:event name=&quot;enemy-collision&quot; handler=&quot;onEnemyCollision&quot; /&gt;
    &lt;qg:event name=&quot;fell-in-pit&quot; handler=&quot;onFellInPit&quot; /&gt;
    &lt;qg:event name=&quot;death-animation-complete&quot; handler=&quot;onDeathAnimationComplete&quot; /&gt;
    &lt;qg:event name=&quot;level-complete&quot; handler=&quot;onLevelComplete&quot; /&gt;
    &lt;qg:event name=&quot;game-init&quot; handler=&quot;onGameInit&quot; /&gt;

    &lt;q:function name=&quot;onGameInit&quot;&gt;
      // Iris-in effect on level start
      game.irisIn(null, 45)

      // Restore lives and score from sessionStorage (after death respawn)
      const savedLives = sessionStorage.getItem(&#x27;mario_lives&#x27;)
      const savedScore = sessionStorage.getItem(&#x27;mario_score&#x27;)
      if (savedLives !== null) {
        lives = parseInt(savedLives)
        document.getElementById(&#x27;lives-display&#x27;).textContent = lives
        sessionStorage.removeItem(&#x27;mario_lives&#x27;)
      }
      if (savedScore !== null) {
        score = parseInt(savedScore)
        document.getElementById(&#x27;score-display&#x27;).textContent = score
        sessionStorage.removeItem(&#x27;mario_score&#x27;)
      }

      // Setup Rex AI - all walk left
      game.setRexAI(&#x27;rex1&#x27;, -0.5)
      game.setRexAI(&#x27;rex2&#x27;, -0.5)
      game.setRexAI(&#x27;rex3&#x27;, -0.5)
      game.setRexAI(&#x27;rex4&#x27;, -0.5)
      game.setRexAI(&#x27;rex5&#x27;, -0.5)
      game.setRexAI(&#x27;rex6&#x27;, -0.5)
      game.setRexAI(&#x27;rex7&#x27;, -0.5)
      game.setRexAI(&#x27;rex8&#x27;, -0.5)
      game.setRexAI(&#x27;rex9&#x27;, -0.5)
      game.setRexAI(&#x27;rex10&#x27;, -0.5)
      game.setRexAI(&#x27;rex11&#x27;, -0.5)
      game.setRexAI(&#x27;rex12&#x27;, -0.5)

      // Handle music autoplay - try to play, if blocked wait for interaction
      const tryPlayMusic = () =&gt; {
        game.playSound(&#x27;bgm-level&#x27;, { loop: true, volume: 0.5 })
      }
      // Browser autoplay requires user gesture - add click handler
      const startMusic = () =&gt; {
        tryPlayMusic()
        document.removeEventListener(&#x27;click&#x27;, startMusic)
        document.removeEventListener(&#x27;keydown&#x27;, startMusic)
      }
      document.addEventListener(&#x27;click&#x27;, startMusic, { once: true })
      document.addEventListener(&#x27;keydown&#x27;, startMusic, { once: true })
    &lt;/q:function&gt;

    &lt;q:function name=&quot;onCoinCollected&quot;&gt;
      coins = coins + 1
      score = score + 10
      document.getElementById(&#x27;coin-display&#x27;).textContent = coins
      document.getElementById(&#x27;score-display&#x27;).textContent = score
    &lt;/q:function&gt;

    &lt;q:function name=&quot;onBlockHit&quot;&gt;
      if (!data || !data.other) return
      if (data.other._blockUsed) return
      game.hitBlock(data.other, &#x27;assets/smw/sprites/qblock_used.png&#x27;, &#x27;assets/smw/sprites/coin_animated.png&#x27;, 16, 16)
      coins = coins + 1
      score = score + 10
      document.getElementById(&#x27;coin-display&#x27;).textContent = coins
      document.getElementById(&#x27;score-display&#x27;).textContent = score
    &lt;/q:function&gt;

    &lt;q:function name=&quot;onEnemyCollision&quot;&gt;
      if (!data || !data.other) return
      if (isDead) return
      const mario = _sprites[&#x27;mario&#x27;]
      const enemy = data.other
      if (!mario || !enemy || !mario.body || !enemy.body) return

      // Rex is 12x24, Mario is 16x24
      // Body positions are at center
      const marioFeet = mario.body.position.y + 12
      const rexHead = enemy.body.position.y - (enemy._rexSquished ? 6 : 12)
      const marioVelY = mario.body.velocity.y

      // Stomp: Mario&#x27;s feet must be above Rex&#x27;s head AND Mario must be falling
      // More strict check: feet must be clearly above head (not just touching)
      const isAbove = marioFeet &amp;lt; rexHead + 4
      const isFalling = marioVelY &gt; 0.5

      if (isAbove &amp;amp;&amp;amp; isFalling) {
        // Stomp! Emit sound event
        _gameEvents.emit(&#x27;enemy-stomped&#x27;, { enemy: enemy.id })

        // Check if Rex already squished
        if (enemy._rexSquished) {
          // Second stomp - kill Rex
          game.destroySprite(enemy.id)
          score = score + 200
        } else {
          // First stomp - squish Rex (makes it shorter and faster)
          enemy._rexSquished = true
          enemy.sprite.scale.y = 0.5
          enemy._rexSpeed = (enemy._rexSpeed || 0.4) * 1.5
          score = score + 100
        }
        // Bounce Mario up
        Matter.Body.setVelocity(mario.body, { x: mario.body.velocity.x, y: -6 })
        document.getElementById(&#x27;score-display&#x27;).textContent = score
      } else {
        // Side collision - Mario dies!
        isDead = 1
        lives = lives - 1
        document.getElementById(&#x27;lives-display&#x27;).textContent = lives
        _gameEvents.emit(&#x27;mario-died&#x27;, {})
        game.killPlayer(&#x27;mario&#x27;)
      }
    &lt;/q:function&gt;

    &lt;q:function name=&quot;onFellInPit&quot;&gt;
      if (isDead) return
      isDead = 1
      lives = lives - 1
      document.getElementById(&#x27;lives-display&#x27;).textContent = lives
      _gameEvents.emit(&#x27;mario-died&#x27;, {})
      game.killPlayer(&#x27;mario&#x27;)
    &lt;/q:function&gt;

    &lt;q:function name=&quot;onDeathAnimationComplete&quot;&gt;
      // Iris-out effect before transition
      game.irisOut(function() {
        if (lives &amp;lt;= 0) {
          // Game Over
          document.getElementById(&#x27;gameover-score&#x27;).textContent = score
          document.getElementById(&#x27;game-over&#x27;).style.display = &#x27;block&#x27;
        } else {
          // Reload entire level (enemies, blocks, everything back to initial state)
          // Store lives in sessionStorage to preserve across reload
          sessionStorage.setItem(&#x27;mario_lives&#x27;, lives)
          sessionStorage.setItem(&#x27;mario_score&#x27;, score)
          location.reload()
        }
      }, 30)
    &lt;/q:function&gt;

    &lt;q:function name=&quot;onLevelComplete&quot;&gt;
      // Stop background music
      game.stopSound(&#x27;bgm-level&#x27;)
      game.pause()
      score = score + 1000

      // Iris-out effect then show level complete
      game.irisOut(function() {
        document.getElementById(&#x27;final-score&#x27;).textContent = score
        document.getElementById(&#x27;level-complete&#x27;).style.display = &#x27;block&#x27;
      }, 45)
    &lt;/q:function&gt;
  &lt;/qg:scene&gt;
&lt;/q:application&gt;
</pre>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20/build/matter.min.js"></script>
  <script>
function toggleSource() {
  var modal = document.getElementById('qg-source-modal');
  modal.classList.toggle('visible');
}
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    document.getElementById('qg-source-modal').classList.remove('visible');
  }
});
(async function() {

  // === PIXI APP ===
  const app = new PIXI.Application();
  await app.init({ width: 256, height: 224, background: "#5C94FC" });
  document.body.appendChild(app.canvas);
  // World size: 5120x432, Viewport: 256x224

  // === MATTER.JS ENGINE ===
  const mEngine = Matter.Engine.create();
  mEngine.gravity.x = 0;
  mEngine.gravity.y = 1.5;
  // Increase solver iterations for tighter collision resolution
  mEngine.positionIterations = 10;
  mEngine.velocityIterations = 8;
  const mWorld = mEngine.world;

  // === EVENT BUS ===
  // Event Bus
  const _gameEvents = { _listeners: {} };
  _gameEvents.on = function(event, cb) {
    if (!this._listeners[event]) {
      this._listeners[event] = [];
    }
    this._listeners[event].push(cb);
  };
  _gameEvents.off = function(event, cb) {
    if (this._listeners[event]) {
      this._listeners[event] = this._listeners[event].filter(fn => fn !== cb);
    }
  };
  _gameEvents.emit = function(event, data) {
    if (this._listeners[event]) {
      for (const cb of this._listeners[event]) {
        cb(data);
      }
    }
  };

  // === GAME STATE ===
  let coins = 0;
  let score = 0;
  let lives = 3;
  let isDead = 0;

  // === ASSET LOADING ===
  await PIXI.Assets.load(["assets/smw/sounds/music/music-map1.wav", "assets/smw/sounds/smw_coin.wav", "assets/smw/sounds/smw_course_clear.wav", "assets/smw/sounds/smw_jump.wav", "assets/smw/sounds/smw_lost_a_life.wav", "assets/smw/sounds/smw_message_block.wav", "assets/smw/sounds/smw_stomp.wav", "assets/smw/sprites/coin_animated.png", "assets/smw/sprites/mario_death.png", "assets/smw/sprites/mario_small.png", "assets/smw/sprites/qblock_animated.png", "assets/smw/sprites/qblock_used.png", "assets/smw/sprites/rex_walk.png", "assets/smw/sprites/yoshi-island-1.png"]);

  // === ANIMATION SYSTEM ===
  // Animation System
  const _animatedSprites = {};

  function _parseFrames(spec) {
    if (spec.includes('-')) {
      const parts = spec.split('-').map(Number);
      const result = [];
      for (let i = parts[0]; i <= parts[1]; i += 1) {
        result.push(i);
      }
      return result;
    }
    return spec.split(',').map(s => parseInt(s.trim(), 10));
  }

  function _registerAnimation(spriteId, texture, frameW, frameH, anims) {
    if (!texture || !frameW || !frameH) {
      return;
    }
    // PIXI v8: get texture source and dimensions
    const baseTexture = texture.source || texture.baseTexture || texture;
    const texW = texture.width || baseTexture.width || (texture.frame && texture.frame.width) || 0;
    const texH = texture.height || baseTexture.height || (texture.frame && texture.frame.height) || 0;
    if (!texW || !texH) {
      console.warn('Animation failed for', spriteId, '- texture dimensions not found');
      return;
    }
    const cols = Math.floor(texW / frameW);
    const rows = Math.floor(texH / frameH);
    const totalFrames = cols * rows;

    // Build frame textures
    const frameTextures = [];
    for (let i = 0; i <= totalFrames - 1; i += 1) {
      const fx = i % cols;
      const fy = Math.floor(i / cols);
      const rect = new PIXI.Rectangle(fx * frameW, fy * frameH, frameW, frameH);
      const frameTex = new PIXI.Texture({ source: baseTexture, frame: rect });
      frameTextures.push(frameTex);
    }

    // Parse named animations
    const animDefs = {};
    let defaultAnim = null;
    for (const [name, cfg] of Object.entries(anims)) {
      const frames = _parseFrames(cfg.frames);
      const textures = frames.filter(f => f < frameTextures.length).map(f => frameTextures[f]);
      if (textures.length > 0) {
        animDefs[name] = { textures: textures, speed: cfg.speed || 0.1, loop: cfg.loop !== false };
        if (cfg.autoPlay) {
          defaultAnim = name;
        }
      }
    }

    if (Object.keys(animDefs).length === 0) {
      return;
    }

    if (!defaultAnim) {
      defaultAnim = Object.keys(animDefs)[0];
    }

    // Create animated sprite
    const firstAnim = animDefs[defaultAnim];
    const animSprite = new PIXI.AnimatedSprite(firstAnim.textures);
    animSprite.animationSpeed = firstAnim.speed;
    if (firstAnim.loop !== false) {
      animSprite.loop = true;
    }
    animSprite.play();

    // Copy transform from static sprite
    const info = _sprites[spriteId];
    if (info) {
      const oldSprite = info.sprite;
      animSprite.x = oldSprite.x;
      animSprite.y = oldSprite.y;
      animSprite.anchor.x = oldSprite.anchor ? oldSprite.anchor.x : 0.5;
      animSprite.anchor.y = oldSprite.anchor ? oldSprite.anchor.y : 0.5;
      animSprite.alpha = oldSprite.alpha;
      animSprite.visible = oldSprite.visible;

      // Replace in container
      const parent = oldSprite.parent;
      if (parent) {
        const idx = parent.getChildIndex(oldSprite);
        parent.removeChild(oldSprite);
        parent.addChildAt(animSprite, idx);
      }
      info.sprite = animSprite;
      _animatedSprites[spriteId] = { anims: animDefs, current: defaultAnim, sprite: animSprite };
    }
  }

  function _switchAnimation(spriteId, animName) {
    const entry = _animatedSprites[spriteId];
    if (!entry || entry.current === animName || !entry.anims[animName]) {
      return;
    }
    const anim = entry.anims[animName];
    entry.sprite.textures = anim.textures;
    entry.sprite.animationSpeed = anim.speed;
    entry.sprite.loop = anim.loop !== false;
    entry.sprite.gotoAndPlay(0);
    entry.current = animName;
  }

  function _updateAnimatedSprites(ticker) {
    for (const [spriteId, entry] of Object.entries(_animatedSprites)) {
      if (entry.sprite && entry.sprite.playing) {
        // PIXI v8: manually update animation using deltaMS
        entry.sprite.update(ticker);
      }
    }
  }

  function _updateControlAnimations() {
    for (const [spriteId, ctrl] of Object.entries(_controlledSprites)) {
      const entry = _animatedSprites[spriteId];
      if (!entry) {
        continue;
      }
      const info = _sprites[spriteId];
      if (!info || !info.body) {
        continue;
      }
      const vx = Math.abs(info.body.velocity.x);
      const vy = info.body.velocity.y;

      // Priority: jump > walk > idle
      if (Math.abs(vy) > 5 && entry.anims['jump']) {
        _switchAnimation(spriteId, 'jump');
      } else if (vx > 0.1 && _keys[ctrl.right] && entry.anims['walk-right']) {
        _switchAnimation(spriteId, 'walk-right');
      } else if (vx > 0.1 && _keys[ctrl.left] && entry.anims['walk-left']) {
        _switchAnimation(spriteId, 'walk-left');
      } else if (vx > 0.1 && (entry.anims['walk'] || entry.anims['walk-right'])) {
        _switchAnimation(spriteId, entry.anims['walk'] ? 'walk' : 'walk-right');
      } else if (entry.anims['idle']) {
        _switchAnimation(spriteId, 'idle');
      }
    }
  }

  // === BEHAVIORS ===
  // no behaviors

  // === CAMERA ===
  const _cameraContainer = new PIXI.Container();
  app.stage.addChild(_cameraContainer);
  const _camera = { targetId: "mario", lerp: 0.08 };

  function updateCamera() {
    const info = _sprites[_camera.targetId];
    if (!info) {
      return;
    }
    const tx = app.screen.width / 2 - info.sprite.x;
    const ty = app.screen.height / 2 - info.sprite.y;
    _cameraContainer.x += (tx - _cameraContainer.x) * _camera.lerp;
    _cameraContainer.y += (ty - _cameraContainer.y) * _camera.lerp;
    _cameraContainer.x = Math.min(0, Math.max(app.screen.width - 5120, _cameraContainer.x));
    _cameraContainer.y = Math.min(0, Math.max(app.screen.height - 432, _cameraContainer.y));
  }

  // === VISUAL TILEMAPS ===
  // No visual tile layers

  // === SPRITES & BODIES ===
  const _sprites = {};
  const _bodyToSprite = {};
  const _spr__preload_used = PIXI.Sprite.from("assets/smw/sprites/qblock_used.png");
  _spr__preload_used.x = -100;
  _spr__preload_used.y = -100;
  _spr__preload_used.anchor.set(0.5, 0.5);
  _spr__preload_used.width = 16;
  _spr__preload_used.height = 16;
  _spr__preload_used.visible = false;
  _cameraContainer.addChild(_spr__preload_used);
  _sprites["_preload_used"] = { id: "_preload_used", sprite: _spr__preload_used, body: null, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr__preload_death = PIXI.Sprite.from("assets/smw/sprites/mario_death.png");
  _spr__preload_death.x = -100;
  _spr__preload_death.y = -100;
  _spr__preload_death.anchor.set(0.5, 0.5);
  _spr__preload_death.width = 16;
  _spr__preload_death.height = 16;
  _spr__preload_death.visible = false;
  _cameraContainer.addChild(_spr__preload_death);
  _sprites["_preload_death"] = { id: "_preload_death", sprite: _spr__preload_death, body: null, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr_level_bg = PIXI.Sprite.from("assets/smw/sprites/yoshi-island-1.png");
  _spr_level_bg.x = 2560;
  _spr_level_bg.y = 216;
  _spr_level_bg.anchor.set(0.5, 0.5);
  _spr_level_bg.width = 5120;
  _spr_level_bg.height = 432;
  _cameraContainer.addChild(_spr_level_bg);
  _sprites["level-bg"] = { id: "level-bg", sprite: _spr_level_bg, body: null, tag: null, collisionHandlers: [], behaviors: [] };

  const _spr_ground = new PIXI.Graphics();
  _spr_ground.rect(-2560.0, -16.0, 5120.0, 32.0);
  _spr_ground.fill({ color: 0x4a9eff });
  _spr_ground.x = 2560;
  _spr_ground.y = 399;
  _spr_ground.visible = false;
  _cameraContainer.addChild(_spr_ground);
  const _body_ground = Matter.Bodies.rectangle(2560, 399, 5120, 32, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_ground.id] = "ground";
  _sprites["ground"] = { id: "ground", sprite: _spr_ground, body: _body_ground, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_step1 = new PIXI.Graphics();
  _spr_hill1_step1.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_step1.fill({ color: 0x00FF00 });
  _spr_hill1_step1.x = 190;
  _spr_hill1_step1.y = 375;
  _cameraContainer.addChild(_spr_hill1_step1);
  const _body_hill1_step1 = Matter.Bodies.rectangle(190, 375, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_step1.id] = "hill1-step1";
  _sprites["hill1-step1"] = { id: "hill1-step1", sprite: _spr_hill1_step1, body: _body_hill1_step1, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_step2 = new PIXI.Graphics();
  _spr_hill1_step2.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_step2.fill({ color: 0x00FF00 });
  _spr_hill1_step2.x = 230;
  _spr_hill1_step2.y = 359;
  _cameraContainer.addChild(_spr_hill1_step2);
  const _body_hill1_step2 = Matter.Bodies.rectangle(230, 359, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_step2.id] = "hill1-step2";
  _sprites["hill1-step2"] = { id: "hill1-step2", sprite: _spr_hill1_step2, body: _body_hill1_step2, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_step3 = new PIXI.Graphics();
  _spr_hill1_step3.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_step3.fill({ color: 0x00FF00 });
  _spr_hill1_step3.x = 270;
  _spr_hill1_step3.y = 343;
  _cameraContainer.addChild(_spr_hill1_step3);
  const _body_hill1_step3 = Matter.Bodies.rectangle(270, 343, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_step3.id] = "hill1-step3";
  _sprites["hill1-step3"] = { id: "hill1-step3", sprite: _spr_hill1_step3, body: _body_hill1_step3, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_step4 = new PIXI.Graphics();
  _spr_hill1_step4.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_step4.fill({ color: 0x00FF00 });
  _spr_hill1_step4.x = 310;
  _spr_hill1_step4.y = 327;
  _cameraContainer.addChild(_spr_hill1_step4);
  const _body_hill1_step4 = Matter.Bodies.rectangle(310, 327, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_step4.id] = "hill1-step4";
  _sprites["hill1-step4"] = { id: "hill1-step4", sprite: _spr_hill1_step4, body: _body_hill1_step4, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_top = new PIXI.Graphics();
  _spr_hill1_top.rect(-30.0, -8.0, 60.0, 16.0);
  _spr_hill1_top.fill({ color: 0x00FF00 });
  _spr_hill1_top.x = 360;
  _spr_hill1_top.y = 311;
  _cameraContainer.addChild(_spr_hill1_top);
  const _body_hill1_top = Matter.Bodies.rectangle(360, 311, 60, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_top.id] = "hill1-top";
  _sprites["hill1-top"] = { id: "hill1-top", sprite: _spr_hill1_top, body: _body_hill1_top, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_down1 = new PIXI.Graphics();
  _spr_hill1_down1.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_down1.fill({ color: 0x00FF00 });
  _spr_hill1_down1.x = 410;
  _spr_hill1_down1.y = 327;
  _cameraContainer.addChild(_spr_hill1_down1);
  const _body_hill1_down1 = Matter.Bodies.rectangle(410, 327, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_down1.id] = "hill1-down1";
  _sprites["hill1-down1"] = { id: "hill1-down1", sprite: _spr_hill1_down1, body: _body_hill1_down1, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_down2 = new PIXI.Graphics();
  _spr_hill1_down2.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_down2.fill({ color: 0x00FF00 });
  _spr_hill1_down2.x = 450;
  _spr_hill1_down2.y = 343;
  _cameraContainer.addChild(_spr_hill1_down2);
  const _body_hill1_down2 = Matter.Bodies.rectangle(450, 343, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_down2.id] = "hill1-down2";
  _sprites["hill1-down2"] = { id: "hill1-down2", sprite: _spr_hill1_down2, body: _body_hill1_down2, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_down3 = new PIXI.Graphics();
  _spr_hill1_down3.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_down3.fill({ color: 0x00FF00 });
  _spr_hill1_down3.x = 490;
  _spr_hill1_down3.y = 359;
  _cameraContainer.addChild(_spr_hill1_down3);
  const _body_hill1_down3 = Matter.Bodies.rectangle(490, 359, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_down3.id] = "hill1-down3";
  _sprites["hill1-down3"] = { id: "hill1-down3", sprite: _spr_hill1_down3, body: _body_hill1_down3, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _spr_hill1_down4 = new PIXI.Graphics();
  _spr_hill1_down4.rect(-20.0, -8.0, 40.0, 16.0);
  _spr_hill1_down4.fill({ color: 0x00FF00 });
  _spr_hill1_down4.x = 530;
  _spr_hill1_down4.y = 375;
  _cameraContainer.addChild(_spr_hill1_down4);
  const _body_hill1_down4 = Matter.Bodies.rectangle(530, 375, 40, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_hill1_down4.id] = "hill1-down4";
  _sprites["hill1-down4"] = { id: "hill1-down4", sprite: _spr_hill1_down4, body: _body_hill1_down4, tag: "terrain", collisionHandlers: [], behaviors: [] };

  const _qb1_baseTex = PIXI.Assets.get("assets/smw/sprites/qblock_animated.png");
  const _qb1_src = _qb1_baseTex.source || _qb1_baseTex.baseTexture || _qb1_baseTex;
  const _qb1_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _qb1_frameTex = new PIXI.Texture({ source: _qb1_src, frame: _qb1_rect });
  const _spr_qb1 = new PIXI.Sprite(_qb1_frameTex);
  _spr_qb1.x = 496;
  _spr_qb1.y = 256;
  _spr_qb1.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_qb1);
  const _body_qb1 = Matter.Bodies.rectangle(496, 256, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_qb1.id] = "qb1";
  _sprites["qb1"] = { id: "qb1", sprite: _spr_qb1, body: _body_qb1, tag: "qblock", collisionHandlers: [], behaviors: [] };

  const _qb2_baseTex = PIXI.Assets.get("assets/smw/sprites/qblock_animated.png");
  const _qb2_src = _qb2_baseTex.source || _qb2_baseTex.baseTexture || _qb2_baseTex;
  const _qb2_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _qb2_frameTex = new PIXI.Texture({ source: _qb2_src, frame: _qb2_rect });
  const _spr_qb2 = new PIXI.Sprite(_qb2_frameTex);
  _spr_qb2.x = 592;
  _spr_qb2.y = 256;
  _spr_qb2.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_qb2);
  const _body_qb2 = Matter.Bodies.rectangle(592, 256, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_qb2.id] = "qb2";
  _sprites["qb2"] = { id: "qb2", sprite: _spr_qb2, body: _body_qb2, tag: "qblock", collisionHandlers: [], behaviors: [] };

  const _qb3_baseTex = PIXI.Assets.get("assets/smw/sprites/qblock_animated.png");
  const _qb3_src = _qb3_baseTex.source || _qb3_baseTex.baseTexture || _qb3_baseTex;
  const _qb3_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _qb3_frameTex = new PIXI.Texture({ source: _qb3_src, frame: _qb3_rect });
  const _spr_qb3 = new PIXI.Sprite(_qb3_frameTex);
  _spr_qb3.x = 1040;
  _spr_qb3.y = 256;
  _spr_qb3.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_qb3);
  const _body_qb3 = Matter.Bodies.rectangle(1040, 256, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_qb3.id] = "qb3";
  _sprites["qb3"] = { id: "qb3", sprite: _spr_qb3, body: _body_qb3, tag: "qblock", collisionHandlers: [], behaviors: [] };

  const _qb4_baseTex = PIXI.Assets.get("assets/smw/sprites/qblock_animated.png");
  const _qb4_src = _qb4_baseTex.source || _qb4_baseTex.baseTexture || _qb4_baseTex;
  const _qb4_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _qb4_frameTex = new PIXI.Texture({ source: _qb4_src, frame: _qb4_rect });
  const _spr_qb4 = new PIXI.Sprite(_qb4_frameTex);
  _spr_qb4.x = 3200;
  _spr_qb4.y = 192;
  _spr_qb4.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_qb4);
  const _body_qb4 = Matter.Bodies.rectangle(3200, 192, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_qb4.id] = "qb4";
  _sprites["qb4"] = { id: "qb4", sprite: _spr_qb4, body: _body_qb4, tag: "qblock", collisionHandlers: [], behaviors: [] };

  const _qb5_baseTex = PIXI.Assets.get("assets/smw/sprites/qblock_animated.png");
  const _qb5_src = _qb5_baseTex.source || _qb5_baseTex.baseTexture || _qb5_baseTex;
  const _qb5_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _qb5_frameTex = new PIXI.Texture({ source: _qb5_src, frame: _qb5_rect });
  const _spr_qb5 = new PIXI.Sprite(_qb5_frameTex);
  _spr_qb5.x = 3216;
  _spr_qb5.y = 192;
  _spr_qb5.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_qb5);
  const _body_qb5 = Matter.Bodies.rectangle(3216, 192, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_qb5.id] = "qb5";
  _sprites["qb5"] = { id: "qb5", sprite: _spr_qb5, body: _body_qb5, tag: "qblock", collisionHandlers: [], behaviors: [] };

  const _qb6_baseTex = PIXI.Assets.get("assets/smw/sprites/qblock_animated.png");
  const _qb6_src = _qb6_baseTex.source || _qb6_baseTex.baseTexture || _qb6_baseTex;
  const _qb6_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _qb6_frameTex = new PIXI.Texture({ source: _qb6_src, frame: _qb6_rect });
  const _spr_qb6 = new PIXI.Sprite(_qb6_frameTex);
  _spr_qb6.x = 3232;
  _spr_qb6.y = 192;
  _spr_qb6.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_qb6);
  const _body_qb6 = Matter.Bodies.rectangle(3232, 192, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_qb6.id] = "qb6";
  _sprites["qb6"] = { id: "qb6", sprite: _spr_qb6, body: _body_qb6, tag: "qblock", collisionHandlers: [], behaviors: [] };

  const _qb7_baseTex = PIXI.Assets.get("assets/smw/sprites/qblock_animated.png");
  const _qb7_src = _qb7_baseTex.source || _qb7_baseTex.baseTexture || _qb7_baseTex;
  const _qb7_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _qb7_frameTex = new PIXI.Texture({ source: _qb7_src, frame: _qb7_rect });
  const _spr_qb7 = new PIXI.Sprite(_qb7_frameTex);
  _spr_qb7.x = 3248;
  _spr_qb7.y = 192;
  _spr_qb7.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_qb7);
  const _body_qb7 = Matter.Bodies.rectangle(3248, 192, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01 });
  _bodyToSprite[_body_qb7.id] = "qb7";
  _sprites["qb7"] = { id: "qb7", sprite: _spr_qb7, body: _body_qb7, tag: "qblock", collisionHandlers: [], behaviors: [] };

  const _coin_7_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_7_src = _coin_7_baseTex.source || _coin_7_baseTex.baseTexture || _coin_7_baseTex;
  const _coin_7_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_7_frameTex = new PIXI.Texture({ source: _coin_7_src, frame: _coin_7_rect });
  const _spr_coin_7 = new PIXI.Sprite(_coin_7_frameTex);
  _spr_coin_7.x = 160;
  _spr_coin_7.y = 288;
  _spr_coin_7.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_7);
  const _body_coin_7 = Matter.Bodies.rectangle(160, 288, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_7.id] = "coin_7";
  _sprites["coin_7"] = { id: "coin_7", sprite: _spr_coin_7, body: _body_coin_7, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_8_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_8_src = _coin_8_baseTex.source || _coin_8_baseTex.baseTexture || _coin_8_baseTex;
  const _coin_8_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_8_frameTex = new PIXI.Texture({ source: _coin_8_src, frame: _coin_8_rect });
  const _spr_coin_8 = new PIXI.Sprite(_coin_8_frameTex);
  _spr_coin_8.x = 528;
  _spr_coin_8.y = 224;
  _spr_coin_8.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_8);
  const _body_coin_8 = Matter.Bodies.rectangle(528, 224, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_8.id] = "coin_8";
  _sprites["coin_8"] = { id: "coin_8", sprite: _spr_coin_8, body: _body_coin_8, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_9_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_9_src = _coin_9_baseTex.source || _coin_9_baseTex.baseTexture || _coin_9_baseTex;
  const _coin_9_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_9_frameTex = new PIXI.Texture({ source: _coin_9_src, frame: _coin_9_rect });
  const _spr_coin_9 = new PIXI.Sprite(_coin_9_frameTex);
  _spr_coin_9.x = 560;
  _spr_coin_9.y = 224;
  _spr_coin_9.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_9);
  const _body_coin_9 = Matter.Bodies.rectangle(560, 224, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_9.id] = "coin_9";
  _sprites["coin_9"] = { id: "coin_9", sprite: _spr_coin_9, body: _body_coin_9, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_10_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_10_src = _coin_10_baseTex.source || _coin_10_baseTex.baseTexture || _coin_10_baseTex;
  const _coin_10_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_10_frameTex = new PIXI.Texture({ source: _coin_10_src, frame: _coin_10_rect });
  const _spr_coin_10 = new PIXI.Sprite(_coin_10_frameTex);
  _spr_coin_10.x = 1600;
  _spr_coin_10.y = 288;
  _spr_coin_10.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_10);
  const _body_coin_10 = Matter.Bodies.rectangle(1600, 288, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_10.id] = "coin_10";
  _sprites["coin_10"] = { id: "coin_10", sprite: _spr_coin_10, body: _body_coin_10, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_11_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_11_src = _coin_11_baseTex.source || _coin_11_baseTex.baseTexture || _coin_11_baseTex;
  const _coin_11_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_11_frameTex = new PIXI.Texture({ source: _coin_11_src, frame: _coin_11_rect });
  const _spr_coin_11 = new PIXI.Sprite(_coin_11_frameTex);
  _spr_coin_11.x = 2656;
  _spr_coin_11.y = 176;
  _spr_coin_11.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_11);
  const _body_coin_11 = Matter.Bodies.rectangle(2656, 176, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_11.id] = "coin_11";
  _sprites["coin_11"] = { id: "coin_11", sprite: _spr_coin_11, body: _body_coin_11, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_12_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_12_src = _coin_12_baseTex.source || _coin_12_baseTex.baseTexture || _coin_12_baseTex;
  const _coin_12_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_12_frameTex = new PIXI.Texture({ source: _coin_12_src, frame: _coin_12_rect });
  const _spr_coin_12 = new PIXI.Sprite(_coin_12_frameTex);
  _spr_coin_12.x = 2672;
  _spr_coin_12.y = 176;
  _spr_coin_12.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_12);
  const _body_coin_12 = Matter.Bodies.rectangle(2672, 176, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_12.id] = "coin_12";
  _sprites["coin_12"] = { id: "coin_12", sprite: _spr_coin_12, body: _body_coin_12, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_13_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_13_src = _coin_13_baseTex.source || _coin_13_baseTex.baseTexture || _coin_13_baseTex;
  const _coin_13_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_13_frameTex = new PIXI.Texture({ source: _coin_13_src, frame: _coin_13_rect });
  const _spr_coin_13 = new PIXI.Sprite(_coin_13_frameTex);
  _spr_coin_13.x = 2688;
  _spr_coin_13.y = 176;
  _spr_coin_13.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_13);
  const _body_coin_13 = Matter.Bodies.rectangle(2688, 176, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_13.id] = "coin_13";
  _sprites["coin_13"] = { id: "coin_13", sprite: _spr_coin_13, body: _body_coin_13, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_14_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_14_src = _coin_14_baseTex.source || _coin_14_baseTex.baseTexture || _coin_14_baseTex;
  const _coin_14_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_14_frameTex = new PIXI.Texture({ source: _coin_14_src, frame: _coin_14_rect });
  const _spr_coin_14 = new PIXI.Sprite(_coin_14_frameTex);
  _spr_coin_14.x = 2704;
  _spr_coin_14.y = 176;
  _spr_coin_14.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_14);
  const _body_coin_14 = Matter.Bodies.rectangle(2704, 176, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_14.id] = "coin_14";
  _sprites["coin_14"] = { id: "coin_14", sprite: _spr_coin_14, body: _body_coin_14, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_15_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_15_src = _coin_15_baseTex.source || _coin_15_baseTex.baseTexture || _coin_15_baseTex;
  const _coin_15_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_15_frameTex = new PIXI.Texture({ source: _coin_15_src, frame: _coin_15_rect });
  const _spr_coin_15 = new PIXI.Sprite(_coin_15_frameTex);
  _spr_coin_15.x = 2720;
  _spr_coin_15.y = 176;
  _spr_coin_15.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_15);
  const _body_coin_15 = Matter.Bodies.rectangle(2720, 176, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_15.id] = "coin_15";
  _sprites["coin_15"] = { id: "coin_15", sprite: _spr_coin_15, body: _body_coin_15, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_16_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_16_src = _coin_16_baseTex.source || _coin_16_baseTex.baseTexture || _coin_16_baseTex;
  const _coin_16_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_16_frameTex = new PIXI.Texture({ source: _coin_16_src, frame: _coin_16_rect });
  const _spr_coin_16 = new PIXI.Sprite(_coin_16_frameTex);
  _spr_coin_16.x = 3600;
  _spr_coin_16.y = 272;
  _spr_coin_16.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_16);
  const _body_coin_16 = Matter.Bodies.rectangle(3600, 272, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_16.id] = "coin_16";
  _sprites["coin_16"] = { id: "coin_16", sprite: _spr_coin_16, body: _body_coin_16, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_17_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_17_src = _coin_17_baseTex.source || _coin_17_baseTex.baseTexture || _coin_17_baseTex;
  const _coin_17_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_17_frameTex = new PIXI.Texture({ source: _coin_17_src, frame: _coin_17_rect });
  const _spr_coin_17 = new PIXI.Sprite(_coin_17_frameTex);
  _spr_coin_17.x = 3616;
  _spr_coin_17.y = 272;
  _spr_coin_17.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_17);
  const _body_coin_17 = Matter.Bodies.rectangle(3616, 272, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_17.id] = "coin_17";
  _sprites["coin_17"] = { id: "coin_17", sprite: _spr_coin_17, body: _body_coin_17, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_18_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_18_src = _coin_18_baseTex.source || _coin_18_baseTex.baseTexture || _coin_18_baseTex;
  const _coin_18_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_18_frameTex = new PIXI.Texture({ source: _coin_18_src, frame: _coin_18_rect });
  const _spr_coin_18 = new PIXI.Sprite(_coin_18_frameTex);
  _spr_coin_18.x = 4080;
  _spr_coin_18.y = 288;
  _spr_coin_18.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_18);
  const _body_coin_18 = Matter.Bodies.rectangle(4080, 288, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_18.id] = "coin_18";
  _sprites["coin_18"] = { id: "coin_18", sprite: _spr_coin_18, body: _body_coin_18, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_19_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_19_src = _coin_19_baseTex.source || _coin_19_baseTex.baseTexture || _coin_19_baseTex;
  const _coin_19_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_19_frameTex = new PIXI.Texture({ source: _coin_19_src, frame: _coin_19_rect });
  const _spr_coin_19 = new PIXI.Sprite(_coin_19_frameTex);
  _spr_coin_19.x = 4096;
  _spr_coin_19.y = 288;
  _spr_coin_19.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_19);
  const _body_coin_19 = Matter.Bodies.rectangle(4096, 288, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_19.id] = "coin_19";
  _sprites["coin_19"] = { id: "coin_19", sprite: _spr_coin_19, body: _body_coin_19, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _coin_20_baseTex = PIXI.Assets.get("assets/smw/sprites/coin_animated.png");
  const _coin_20_src = _coin_20_baseTex.source || _coin_20_baseTex.baseTexture || _coin_20_baseTex;
  const _coin_20_rect = new PIXI.Rectangle(0, 0, 16, 16);
  const _coin_20_frameTex = new PIXI.Texture({ source: _coin_20_src, frame: _coin_20_rect });
  const _spr_coin_20 = new PIXI.Sprite(_coin_20_frameTex);
  _spr_coin_20.x = 4112;
  _spr_coin_20.y = 288;
  _spr_coin_20.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_coin_20);
  const _body_coin_20 = Matter.Bodies.rectangle(4112, 288, 16, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_coin_20.id] = "coin_20";
  _sprites["coin_20"] = { id: "coin_20", sprite: _spr_coin_20, body: _body_coin_20, tag: "coin", collisionHandlers: [], behaviors: [] };

  const _rex1_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex1_src = _rex1_baseTex.source || _rex1_baseTex.baseTexture || _rex1_baseTex;
  const _rex1_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex1_frameTex = new PIXI.Texture({ source: _rex1_src, frame: _rex1_rect });
  const _spr_rex1 = new PIXI.Sprite(_rex1_frameTex);
  _spr_rex1.x = 450;
  _spr_rex1.y = 371;
  _spr_rex1.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex1);
  const _body_rex1 = Matter.Bodies.rectangle(450, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex1.id] = "rex1";
  _sprites["rex1"] = { id: "rex1", sprite: _spr_rex1, body: _body_rex1, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex2_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex2_src = _rex2_baseTex.source || _rex2_baseTex.baseTexture || _rex2_baseTex;
  const _rex2_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex2_frameTex = new PIXI.Texture({ source: _rex2_src, frame: _rex2_rect });
  const _spr_rex2 = new PIXI.Sprite(_rex2_frameTex);
  _spr_rex2.x = 700;
  _spr_rex2.y = 371;
  _spr_rex2.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex2);
  const _body_rex2 = Matter.Bodies.rectangle(700, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex2.id] = "rex2";
  _sprites["rex2"] = { id: "rex2", sprite: _spr_rex2, body: _body_rex2, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex3_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex3_src = _rex3_baseTex.source || _rex3_baseTex.baseTexture || _rex3_baseTex;
  const _rex3_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex3_frameTex = new PIXI.Texture({ source: _rex3_src, frame: _rex3_rect });
  const _spr_rex3 = new PIXI.Sprite(_rex3_frameTex);
  _spr_rex3.x = 950;
  _spr_rex3.y = 371;
  _spr_rex3.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex3);
  const _body_rex3 = Matter.Bodies.rectangle(950, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex3.id] = "rex3";
  _sprites["rex3"] = { id: "rex3", sprite: _spr_rex3, body: _body_rex3, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex4_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex4_src = _rex4_baseTex.source || _rex4_baseTex.baseTexture || _rex4_baseTex;
  const _rex4_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex4_frameTex = new PIXI.Texture({ source: _rex4_src, frame: _rex4_rect });
  const _spr_rex4 = new PIXI.Sprite(_rex4_frameTex);
  _spr_rex4.x = 1300;
  _spr_rex4.y = 371;
  _spr_rex4.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex4);
  const _body_rex4 = Matter.Bodies.rectangle(1300, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex4.id] = "rex4";
  _sprites["rex4"] = { id: "rex4", sprite: _spr_rex4, body: _body_rex4, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex5_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex5_src = _rex5_baseTex.source || _rex5_baseTex.baseTexture || _rex5_baseTex;
  const _rex5_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex5_frameTex = new PIXI.Texture({ source: _rex5_src, frame: _rex5_rect });
  const _spr_rex5 = new PIXI.Sprite(_rex5_frameTex);
  _spr_rex5.x = 1600;
  _spr_rex5.y = 371;
  _spr_rex5.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex5);
  const _body_rex5 = Matter.Bodies.rectangle(1600, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex5.id] = "rex5";
  _sprites["rex5"] = { id: "rex5", sprite: _spr_rex5, body: _body_rex5, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex6_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex6_src = _rex6_baseTex.source || _rex6_baseTex.baseTexture || _rex6_baseTex;
  const _rex6_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex6_frameTex = new PIXI.Texture({ source: _rex6_src, frame: _rex6_rect });
  const _spr_rex6 = new PIXI.Sprite(_rex6_frameTex);
  _spr_rex6.x = 1900;
  _spr_rex6.y = 371;
  _spr_rex6.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex6);
  const _body_rex6 = Matter.Bodies.rectangle(1900, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex6.id] = "rex6";
  _sprites["rex6"] = { id: "rex6", sprite: _spr_rex6, body: _body_rex6, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex7_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex7_src = _rex7_baseTex.source || _rex7_baseTex.baseTexture || _rex7_baseTex;
  const _rex7_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex7_frameTex = new PIXI.Texture({ source: _rex7_src, frame: _rex7_rect });
  const _spr_rex7 = new PIXI.Sprite(_rex7_frameTex);
  _spr_rex7.x = 2200;
  _spr_rex7.y = 371;
  _spr_rex7.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex7);
  const _body_rex7 = Matter.Bodies.rectangle(2200, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex7.id] = "rex7";
  _sprites["rex7"] = { id: "rex7", sprite: _spr_rex7, body: _body_rex7, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex8_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex8_src = _rex8_baseTex.source || _rex8_baseTex.baseTexture || _rex8_baseTex;
  const _rex8_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex8_frameTex = new PIXI.Texture({ source: _rex8_src, frame: _rex8_rect });
  const _spr_rex8 = new PIXI.Sprite(_rex8_frameTex);
  _spr_rex8.x = 2700;
  _spr_rex8.y = 371;
  _spr_rex8.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex8);
  const _body_rex8 = Matter.Bodies.rectangle(2700, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex8.id] = "rex8";
  _sprites["rex8"] = { id: "rex8", sprite: _spr_rex8, body: _body_rex8, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex9_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex9_src = _rex9_baseTex.source || _rex9_baseTex.baseTexture || _rex9_baseTex;
  const _rex9_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex9_frameTex = new PIXI.Texture({ source: _rex9_src, frame: _rex9_rect });
  const _spr_rex9 = new PIXI.Sprite(_rex9_frameTex);
  _spr_rex9.x = 3100;
  _spr_rex9.y = 371;
  _spr_rex9.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex9);
  const _body_rex9 = Matter.Bodies.rectangle(3100, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex9.id] = "rex9";
  _sprites["rex9"] = { id: "rex9", sprite: _spr_rex9, body: _body_rex9, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex10_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex10_src = _rex10_baseTex.source || _rex10_baseTex.baseTexture || _rex10_baseTex;
  const _rex10_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex10_frameTex = new PIXI.Texture({ source: _rex10_src, frame: _rex10_rect });
  const _spr_rex10 = new PIXI.Sprite(_rex10_frameTex);
  _spr_rex10.x = 3500;
  _spr_rex10.y = 371;
  _spr_rex10.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex10);
  const _body_rex10 = Matter.Bodies.rectangle(3500, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex10.id] = "rex10";
  _sprites["rex10"] = { id: "rex10", sprite: _spr_rex10, body: _body_rex10, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex11_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex11_src = _rex11_baseTex.source || _rex11_baseTex.baseTexture || _rex11_baseTex;
  const _rex11_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex11_frameTex = new PIXI.Texture({ source: _rex11_src, frame: _rex11_rect });
  const _spr_rex11 = new PIXI.Sprite(_rex11_frameTex);
  _spr_rex11.x = 3900;
  _spr_rex11.y = 371;
  _spr_rex11.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex11);
  const _body_rex11 = Matter.Bodies.rectangle(3900, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex11.id] = "rex11";
  _sprites["rex11"] = { id: "rex11", sprite: _spr_rex11, body: _body_rex11, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _rex12_baseTex = PIXI.Assets.get("assets/smw/sprites/rex_walk.png");
  const _rex12_src = _rex12_baseTex.source || _rex12_baseTex.baseTexture || _rex12_baseTex;
  const _rex12_rect = new PIXI.Rectangle(0, 0, 12, 24);
  const _rex12_frameTex = new PIXI.Texture({ source: _rex12_src, frame: _rex12_rect });
  const _spr_rex12 = new PIXI.Sprite(_rex12_frameTex);
  _spr_rex12.x = 4300;
  _spr_rex12.y = 371;
  _spr_rex12.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_rex12);
  const _body_rex12 = Matter.Bodies.rectangle(4300, 371, 12, 24, { isStatic: false, restitution: 0.1, friction: 0, slop: 0.01, inertia: Infinity });
  _bodyToSprite[_body_rex12.id] = "rex12";
  _sprites["rex12"] = { id: "rex12", sprite: _spr_rex12, body: _body_rex12, tag: "enemy", collisionHandlers: [], behaviors: [] };

  const _spr_goal = new PIXI.Graphics();
  _spr_goal.rect(-8.0, -40.0, 16.0, 80.0);
  _spr_goal.fill({ color: 0x00FF00 });
  _spr_goal.x = 4950;
  _spr_goal.y = 344;
  _cameraContainer.addChild(_spr_goal);
  const _body_goal = Matter.Bodies.rectangle(4950, 344, 16, 80, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_goal.id] = "goal";
  _sprites["goal"] = { id: "goal", sprite: _spr_goal, body: _body_goal, tag: "goal", collisionHandlers: [], behaviors: [] };

  const _mario_baseTex = PIXI.Assets.get("assets/smw/sprites/mario_small.png");
  const _mario_src = _mario_baseTex.source || _mario_baseTex.baseTexture || _mario_baseTex;
  const _mario_rect = new PIXI.Rectangle(0, 0, 16, 24);
  const _mario_frameTex = new PIXI.Texture({ source: _mario_src, frame: _mario_rect });
  const _spr_mario = new PIXI.Sprite(_mario_frameTex);
  _spr_mario.x = 80;
  _spr_mario.y = 371;
  _spr_mario.anchor.set(0.5, 0.5);
  _cameraContainer.addChild(_spr_mario);
  const _body_mario = Matter.Bodies.rectangle(80, 371, 16, 24, { isStatic: false, restitution: 0.1, friction: 0.1, slop: 0.01, inertia: Infinity, chamfer: { radius: 3 } });
  _bodyToSprite[_body_mario.id] = "mario";
  _sprites["mario"] = { id: "mario", sprite: _spr_mario, body: _body_mario, tag: "player", collisionHandlers: [], behaviors: [] };

  const _spr_deathzone = new PIXI.Graphics();
  _spr_deathzone.rect(-2560.0, -8.0, 5120.0, 16.0);
  _spr_deathzone.fill({ color: 0x4a9eff });
  _spr_deathzone.x = 2560;
  _spr_deathzone.y = 480;
  _spr_deathzone.visible = false;
  _cameraContainer.addChild(_spr_deathzone);
  const _body_deathzone = Matter.Bodies.rectangle(2560, 480, 5120, 16, { isStatic: true, restitution: 0.1, friction: 0.1, slop: 0.01, isSensor: true });
  _bodyToSprite[_body_deathzone.id] = "deathzone";
  _sprites["deathzone"] = { id: "deathzone", sprite: _spr_deathzone, body: _body_deathzone, tag: "death", collisionHandlers: [], behaviors: [] };

  Matter.Composite.add(mWorld, [_body_ground, _body_hill1_step1, _body_hill1_step2, _body_hill1_step3, _body_hill1_step4, _body_hill1_top, _body_hill1_down1, _body_hill1_down2, _body_hill1_down3, _body_hill1_down4, _body_qb1, _body_qb2, _body_qb3, _body_qb4, _body_qb5, _body_qb6, _body_qb7, _body_coin_7, _body_coin_8, _body_coin_9, _body_coin_10, _body_coin_11, _body_coin_12, _body_coin_13, _body_coin_14, _body_coin_15, _body_coin_16, _body_coin_17, _body_coin_18, _body_coin_19, _body_coin_20, _body_rex1, _body_rex2, _body_rex3, _body_rex4, _body_rex5, _body_rex6, _body_rex7, _body_rex8, _body_rex9, _body_rex10, _body_rex11, _body_rex12, _body_goal, _body_mario, _body_deathzone]);

  function syncPhysics() {
    for (const [id, info] of Object.entries(_sprites)) {
      if (info.body && !info.body.isStatic) {
        info.sprite.x = info.body.position.x;
        info.sprite.y = info.body.position.y;
        info.sprite.rotation = info.body.angle;
      }
    }
  }

  // === GAME API ===
  // Game API
  const game = { camera: {} };

  game.destroy = function(info) {
    if (!info) {
      return;
    }
    // Find sprite id
    let spriteId = null;
    for (const [id, entry] of Object.entries(_sprites)) {
      if (entry === info || entry.sprite === info) {
        spriteId = id;
        break;
      }
    }
    if (!spriteId) {
      return;
    }
    const entry = _sprites[spriteId];
    if (entry.sprite && entry.sprite.parent) {
      entry.sprite.parent.removeChild(entry.sprite);
    }
    if (entry.body) {
      Matter.Composite.remove(mWorld, entry.body);
    }
    delete _sprites[spriteId];
  };

  game.play = function(soundId, opts) {
    if (typeof _playSound === 'function') {
      return _playSound(soundId, opts);
    }
  };

  game.stop = function(soundId) {
    if (typeof _stopSound === 'function') {
      _stopSound(soundId);
    }
  };

  game.emit = function(info, event) {
    _gameEvents.emit(event, info);
    if (info && info.tag) {
      _gameEvents.emit(info.tag + '.' + event, info);
    }
  };

  game.loadScene = function(name) {
    if (typeof _loadScene === 'function') {
      _loadScene(name);
    }
  };

  game.respawn = function(id, x, y) {
    const info = _sprites[id];
    if (!info) {
      return;
    }
    if (info.sprite) {
      info.sprite.x = x;
      info.sprite.y = y;
      info.sprite.visible = true;
    }
    if (info.body) {
      Matter.Body.setPosition(info.body, { x: x, y: y });
      Matter.Body.setVelocity(info.body, { x: 0, y: 0 });
    }
  };

  game.destroyGroup = function(groupName) {
    const toRemove = [];
    for (const [id, info] of Object.entries(_sprites)) {
      if (info.group === groupName) {
        toRemove.push(info);
      }
    }
    for (const info of toRemove) {
      game.destroy(info);
    }
  };

  game.moveX = function(info, dx) {
    if (info && info.body) {
      Matter.Body.setVelocity(info.body, { x: dx, y: info.body.velocity.y });
    }
  };

  game.moveToward = function(info, targetId, speed) {
    if (!info || !info.body) {
      return;
    }
    const target = _sprites[targetId];
    if (!target) {
      return;
    }
    const dx = target.sprite.x - info.sprite.x;
    const dy = target.sprite.y - info.sprite.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 1) {
      return;
    }
    Matter.Body.setVelocity(info.body, { x: (dx / dist) * speed, y: (dy / dist) * speed });
  };

  game.patrol = function(info, speed) {
    game.moveX(info, speed);
  };

  game.camera.shake = function(intensity, duration) {
    let _shakeFrames = Math.floor((duration || 0.3) * 60);
    const _shakeIntensity = intensity || 5;
    const origX = _cameraContainer.x;
    const origY = _cameraContainer.y;
    const _shakeTick = () => {
      if (_shakeFrames <= 0) {
        _cameraContainer.x = origX;
        _cameraContainer.y = origY;
        return;
      }
      _cameraContainer.x = origX + (Math.random() - 0.5) * _shakeIntensity * 2;
      _cameraContainer.y = origY + (Math.random() - 0.5) * _shakeIntensity * 2;
      _shakeFrames--;
      requestAnimationFrame(_shakeTick);
    };
    _shakeTick();
  };

  game.spawn = function(id) {
    if (typeof _spawn === 'function') {
      _spawn(id);
    }
  };

  game.hitBlock = function(blockInfo, usedTextureSrc, coinTextureSrc, frameW, frameH) {
    if (!blockInfo || blockInfo._blockUsed) {
      return;
    }
    blockInfo._blockUsed = true;

    // Change block texture to used
    if (blockInfo.sprite && usedTextureSrc) {
      const usedTex = PIXI.Assets.get(usedTextureSrc);
      if (usedTex) {
        // Stop animation if playing
        if (blockInfo.sprite.stop) {
          blockInfo.sprite.stop();
        }
        // Get first frame of used texture
        const fw = frameW || 16;
        const fh = frameH || 16;
        const src = usedTex.source || usedTex.baseTexture || usedTex;
        const rect = new PIXI.Rectangle(0, 0, fw, fh);
        const frameTex = new PIXI.Texture({ source: src, frame: rect });
        // Replace with static sprite
        const newSprite = new PIXI.Sprite(frameTex);
        newSprite.anchor.set(0.5);
        newSprite.x = blockInfo.sprite.x;
        newSprite.y = blockInfo.sprite.y;
        const parent = blockInfo.sprite.parent;
        if (parent) {
          parent.removeChild(blockInfo.sprite);
          parent.addChild(newSprite);
        }
        blockInfo.sprite = newSprite;
      }
    }

    // Spawn coin effect above block
    if (coinTextureSrc) {
      const coinTex = PIXI.Assets.get(coinTextureSrc);
      if (coinTex) {
        const cfw = frameW || 16;
        const cfh = frameH || 16;
        const csrc = coinTex.source || coinTex.baseTexture || coinTex;
        // Create animated coin with 4 frames
        const coinFrames = [];
        for (let i = 0; i < 4; i++) {
          const crect = new PIXI.Rectangle(i * cfw, 0, cfw, cfh);
          coinFrames.push(new PIXI.Texture({ source: csrc, frame: crect }));
        }
        const coinSprite = new PIXI.AnimatedSprite(coinFrames);
        coinSprite.anchor.set(0.5);
        coinSprite.x = blockInfo.sprite.x;
        coinSprite.y = blockInfo.sprite.y - 20;
        coinSprite.animationSpeed = 0.15;
        coinSprite.play();
        _cameraContainer.addChild(coinSprite);

        // Animate coin going up and fading
        let coinY = coinSprite.y;
        let coinFrame = 0;
        const coinAnim = () => {;
          coinFrame++;
          coinY = coinY - 2;
          coinSprite.y = coinY;
          coinSprite.alpha = 1 - (coinFrame / 30);
          if (coinFrame < 30) {
            requestAnimationFrame(coinAnim);
          } else {
            coinSprite.destroy();
          }
        };
        coinAnim();
      }
    }
  };

  game.spawnPowerUp = function(blockInfo, textureSrc, moveSpeed) {
    if (!blockInfo || !blockInfo.sprite) {
      return;
    }
    const tex = PIXI.Assets.get(textureSrc);
    if (!tex) {
      console.warn('PowerUp texture not loaded:', textureSrc);
      return;
    }

    // Create mushroom sprite
    const mushSprite = new PIXI.Sprite(tex);
    mushSprite.anchor.set(0.5);
    mushSprite.x = blockInfo.sprite.x;
    mushSprite.y = blockInfo.sprite.y - 16;
    _cameraContainer.addChild(mushSprite);

    // Create physics body for mushroom (no rotation)
    const mushBody = Matter.Bodies.rectangle(mushSprite.x, mushSprite.y, 14, 14, { friction: 0, frictionAir: 0, restitution: 0, inertia: Infinity, label: 'mushroom' });
    Matter.Composite.add(mWorld, mushBody);

    // Register mushroom in sprites
    const mushId = 'powerup_' + Date.now();
    const mushInfo = { id: mushId, sprite: mushSprite, body: mushBody, tag: "powerup", _isPowerUp: true, behaviors: [], collisionHandlers: [] };
    _sprites[mushId] = mushInfo;
    _bodyToSprite[mushBody.id] = mushId;

    // Start mushroom rising animation then walking
    let riseFrames = 0;
    const spd = moveSpeed || 1.5;
    const riseAnim = () => {;
      riseFrames++;
      if (riseFrames < 16) {
        // Rising from block
        mushSprite.y = mushSprite.y - 1;
        Matter.Body.setPosition(mushBody, { x: mushSprite.x, y: mushSprite.y });
        requestAnimationFrame(riseAnim);
      } else {
        // Start walking
        Matter.Body.setVelocity(mushBody, { x: spd, y: 0 });
      }
    };
    riseAnim();
  };

  game.powerUpPlayer = function(playerId, bigSpriteSrc, frameW, frameH) {
    const playerInfo = _sprites[playerId];
    if (!playerInfo || playerInfo._isBig) {
      return;
    }
    playerInfo._isBig = true;

    const bigTex = PIXI.Assets.get(bigSpriteSrc);
    if (!bigTex) {
      console.warn('Big sprite not loaded:', bigSpriteSrc);
      return;
    }

    // Extract frame textures from spritesheet
    const fw = frameW || 16;
    const fh = frameH || 32;
    const src = bigTex.source || bigTex.baseTexture || bigTex;

    // Create textures for each frame
    const allFrames = [];
    for (let i = 0; i < 5; i++) {
      const rect = new PIXI.Rectangle(i * fw, 0, fw, fh);
      allFrames.push(new PIXI.Texture({ source: src, frame: rect }));
    }

    // Create animation sets: idle(0), walk(1-3), jump(4)
    const idleFrames = [allFrames[0]];
    const walkFrames = [allFrames[1], allFrames[2], allFrames[3]];
    const jumpFrames = [allFrames[4]];

    // Create animated sprite starting with idle
    const bigSprite = new PIXI.AnimatedSprite(idleFrames);
    bigSprite.anchor.set(0.5);
    bigSprite.x = playerInfo.sprite.x;
    bigSprite.y = playerInfo.sprite.y - 4;
    bigSprite.scale.x = playerInfo.sprite.scale.x;
    bigSprite.animationSpeed = 0.15;
    bigSprite.loop = true;
    bigSprite.play();

    // Replace sprite in scene
    const parent = playerInfo.sprite.parent;
    if (parent) {
      parent.removeChild(playerInfo.sprite);
      parent.addChild(bigSprite);
    }
    playerInfo.sprite = bigSprite;

    // Update physics body size for big Mario
    if (playerInfo.body) {
      const pos = playerInfo.body.position;
      Matter.Composite.remove(mWorld, playerInfo.body);
      const newBody = Matter.Bodies.rectangle(pos.x, pos.y - 4, 14, 30, { friction: 0, frictionAir: 0, inertia: Infinity, label: 'player' });
      Matter.Composite.add(mWorld, newBody);
      delete _bodyToSprite[playerInfo.body.id];
      playerInfo.body = newBody;
      _bodyToSprite[newBody.id] = playerId;
    }

    // Register animations in the animation system
    _animatedSprites[playerId] = {
      sprite: bigSprite,
      current: 'idle',
      anims: {
        idle: { textures: idleFrames, speed: 0.1, loop: true },
        walk: { textures: walkFrames, speed: 0.18, loop: true },
        jump: { textures: jumpFrames, speed: 0.1, loop: false }
      }
    };
  };

  game.setGoombaAI = function(goombaId, speed) {
    const info = _sprites[goombaId];
    if (!info || !info.body) {
      return;
    }

    // Store the movement speed
    info._goombaSpeed = speed;
    info._goombaDir = speed < 0 ? -1 : 1;

    // Add update behavior for goomba AI
    if (!info.behaviors) {
      info.behaviors = [];
    }
    info.behaviors.push({
      update: function() {
        // Skip if game is paused
        if (game._paused) return;
        const gInfo = _sprites[goombaId];
        if (!gInfo || !gInfo.body) return;

        // Apply constant horizontal velocity
        const currentSpeed = Math.abs(gInfo._goombaSpeed) * gInfo._goombaDir;
        Matter.Body.setVelocity(gInfo.body, { x: currentSpeed, y: gInfo.body.velocity.y });

        // Flip sprite based on direction
        if (gInfo.sprite) {
          gInfo.sprite.scale.x = gInfo._goombaDir > 0 ? -1 : 1;
        }
      }
    });

    // Listen for collisions to change direction
    if (!info.collisionHandlers) {
      info.collisionHandlers = [];
    }
    info.collisionHandlers.push(function(other, collision) {
      const gInfo = _sprites[goombaId];
      if (!gInfo) return;

      // Check if hit a wall or terrain (not player)
      if (other.tag === 'terrain' || other.tag === 'tilemap-collision' || other.tag === 'wall' || other.tag === 'qblock') {
        // Reverse direction
        gInfo._goombaDir *= -1;
      }
    });
  };

  game.setRexAI = game.setGoombaAI;

  game.destroySprite = function(spriteId) {
    const info = _sprites[spriteId];
    if (!info) {
      return;
    }

    // Remove physics body
    if (info.body) {
      Matter.Composite.remove(mWorld, info.body);
      delete _bodyToSprite[info.body.id];
    }

    // Remove sprite from display
    if (info.sprite && info.sprite.parent) {
      info.sprite.parent.removeChild(info.sprite);
    }

    // Remove from animated sprites
    delete _animatedSprites[spriteId];

    // Remove from sprites registry
    delete _sprites[spriteId];
  };

  game.pause = function() {
    game._paused = true;
    // Stop physics engine
    mEngine.timing.timeScale = 0;
    // Stop all animated sprites
    for (const id in _animatedSprites) {
      const anim = _animatedSprites[id];
      if (anim && anim.sprite && anim.sprite.stop) anim.sprite.stop();
    }
    // Store velocities and stop all bodies
    game._savedVelocities = {};
    for (const id in _sprites) {
      const info = _sprites[id];
      if (info.body) {
        game._savedVelocities[id] = { x: info.body.velocity.x, y: info.body.velocity.y };
        Matter.Body.setVelocity(info.body, { x: 0, y: 0 });
      }
    }
  };

  game.resume = function() {
    game._paused = false;
    // Resume physics engine
    mEngine.timing.timeScale = 1;
    // Resume all animated sprites
    for (const id in _animatedSprites) {
      const anim = _animatedSprites[id];
      if (anim && anim.sprite && anim.sprite.play) anim.sprite.play();
    }
    // Restore velocities
    if (game._savedVelocities) {
      for (const id in game._savedVelocities) {
        const info = _sprites[id];
        if (info && info.body) {
          Matter.Body.setVelocity(info.body, game._savedVelocities[id]);
        }
      }
    }
  };

  game.playSound = function(soundId, opts) {
    _playSound(soundId, opts || {});
  };

  game.stopSound = function(soundId) {
    if (_activeSources[soundId]) {
      _activeSources[soundId].stop();
      delete _activeSources[soundId];
    }
  };

  game.stopAllSounds = function() {
    for (const id in _activeSources) {
      _activeSources[id].stop();
      delete _activeSources[id];
    }
  };

  game.irisIn = function(callback, duration) {
    duration = duration || 30;
    const overlay = new PIXI.Graphics();
    overlay.zIndex = 9999;
    app.stage.addChild(overlay);
    app.stage.sortChildren();
    let frame = 0;
    const centerX = app.screen.width / 2;
    const centerY = app.screen.height / 2;
    const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY) + 50;
    const animate = () => {
      frame++;
      const t = frame / duration;
      const radius = maxRadius * t;
      overlay.clear();
      overlay.rect(0, 0, app.screen.width, app.screen.height);
      overlay.fill(0x000000);
      overlay.circle(centerX, centerY, radius);
      overlay.cut();
      if (frame < duration) {
        requestAnimationFrame(animate);
      } else {
        app.stage.removeChild(overlay);
        if (callback) callback();
      }
    };
    animate();
  };

  game.irisOut = function(callback, duration) {
    duration = duration || 30;
    const overlay = new PIXI.Graphics();
    overlay.zIndex = 9999;
    app.stage.addChild(overlay);
    app.stage.sortChildren();
    let frame = 0;
    const centerX = app.screen.width / 2;
    const centerY = app.screen.height / 2;
    const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY) + 50;
    const animate = () => {
      frame++;
      const t = 1 - (frame / duration);
      const radius = maxRadius * t;
      overlay.clear();
      overlay.rect(0, 0, app.screen.width, app.screen.height);
      overlay.fill(0x000000);
      if (radius > 0) {
        overlay.circle(centerX, centerY, radius);
        overlay.cut();
      }
      if (frame < duration) {
        requestAnimationFrame(animate);
      } else {
        if (callback) callback();
      }
    };
    animate();
  };

  game.killPlayer = function(playerId, deathSpriteSrc) {
    const info = _sprites[playerId];
    if (!info || info._isDying) {
      return;
    }
    info._isDying = true;

    // Pause game and stop background music
    game.pause();
    game.stopSound('bgm-level');

    // Swap to death sprite if provided
    const deathSrc = deathSpriteSrc || 'assets/smw/sprites/mario_death.png';
    const deathTex = PIXI.Assets.get(deathSrc);
    if (deathTex) {
      // Store original sprite and create death sprite
      info._originalSprite = info.sprite;
      const deathSprite = PIXI.Sprite.from(deathTex);
      deathSprite.anchor.set(0.5);
      deathSprite.x = info.sprite.x;
      deathSprite.y = info.sprite.y;
      const parent = info.sprite.parent;
      if (parent) {
        parent.removeChild(info.sprite);
        parent.addChild(deathSprite);
      }
      info.sprite = deathSprite;
    }

    // Remove Mario from physics (so he can do death animation)
    if (info.body) {
      Matter.Composite.remove(mWorld, info.body);
      delete _bodyToSprite[info.body.id];
      info._deathBody = info.body;
      info.body = null;
    }

    // Death animation - Mario jumps up then falls (slower, wait for sound)
    let deathY = info.sprite.y;
    let deathVelY = -4;
    let deathFrame = 0;
    let waitFrames = 0;
    const deathAnim = () => {;
      deathFrame++;

      // First phase: jump up and fall
      if (deathY < 600) {
        deathVelY += 0.15;
        deathY += deathVelY;
        info.sprite.y = deathY;
        requestAnimationFrame(deathAnim);
      } else {
        // Second phase: wait for death sound to finish (~4 seconds = 240 frames)
        waitFrames++;
        if (waitFrames < 240) {
          requestAnimationFrame(deathAnim);
        } else {
          // Death animation complete - emit event
          _gameEvents.emit('death-animation-complete', { playerId: playerId });
        }
      }
    };
    requestAnimationFrame(deathAnim);
  };

  // === BEHAVIOR ATTACHMENTS ===
  _sprites["mario"].collisionHandlers.push((self, other) => {
    if (other.tag !== "coin") return;
    _gameEvents.emit("coin-collected", { self, other });
  });
  _sprites["mario"].collisionHandlers.push((self, other) => {
    if (other.tag !== "coin") return;
    if (other._destroyed) return;
    other._destroyed = true;
    if (other.body) { delete _bodyToSprite[other.body.id]; Matter.Composite.remove(mEngine.world, other.body); }
    if (other.sprite) { if (other.sprite.stop) other.sprite.stop(); other.sprite.destroy(); }
    if (other.id) delete _sprites[other.id];
  });
  _sprites["mario"].collisionHandlers.push((self, other) => {
    if (other.tag !== "qblock") return;
    _gameEvents.emit("block-hit", { self, other });
  });
  _sprites["mario"].collisionHandlers.push((self, other) => {
    if (other.tag !== "enemy") return;
    _gameEvents.emit("enemy-collision", { self, other });
  });
  _sprites["mario"].collisionHandlers.push((self, other) => {
    if (other.tag !== "death") return;
    _gameEvents.emit("fell-in-pit", { self, other });
  });
  _sprites["mario"].collisionHandlers.push((self, other) => {
    if (other.tag !== "goal") return;
    _gameEvents.emit("level-complete", { self, other });
  });
  // Init state machines
  for (const [_id, _info] of Object.entries(_sprites)) {
    for (const b of _info.behaviors) {
      if (b._smInit) {
        b._smInit();
      }
    }
  }

  // === ANIMATION REGISTRATION ===
  _registerAnimation("qb1", PIXI.Assets.get("assets/smw/sprites/qblock_animated.png"), 16, 16, { "shine": { frames: "0,1,2,3", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("qb2", PIXI.Assets.get("assets/smw/sprites/qblock_animated.png"), 16, 16, { "shine": { frames: "0,1,2,3", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("qb3", PIXI.Assets.get("assets/smw/sprites/qblock_animated.png"), 16, 16, { "shine": { frames: "0,1,2,3", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("qb4", PIXI.Assets.get("assets/smw/sprites/qblock_animated.png"), 16, 16, { "shine": { frames: "0,1,2,3", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("qb5", PIXI.Assets.get("assets/smw/sprites/qblock_animated.png"), 16, 16, { "shine": { frames: "0,1,2,3", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("qb6", PIXI.Assets.get("assets/smw/sprites/qblock_animated.png"), 16, 16, { "shine": { frames: "0,1,2,3", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("qb7", PIXI.Assets.get("assets/smw/sprites/qblock_animated.png"), 16, 16, { "shine": { frames: "0,1,2,3", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("coin_7", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_8", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_9", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_10", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_11", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_12", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_13", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_14", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_15", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_16", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_17", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_18", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_19", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("coin_20", PIXI.Assets.get("assets/smw/sprites/coin_animated.png"), 16, 16, { "spin": { frames: "0,1,2,3,2,1", speed: 0.12, loop: true, autoPlay: true } });
  _registerAnimation("rex1", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex2", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex3", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex4", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex5", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex6", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex7", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex8", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex9", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex10", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex11", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("rex12", PIXI.Assets.get("assets/smw/sprites/rex_walk.png"), 12, 24, { "walk": { frames: "0-1", speed: 0.15, loop: true, autoPlay: true } });
  _registerAnimation("mario", PIXI.Assets.get("assets/smw/sprites/mario_small.png"), 16, 24, { "idle": { frames: "0", speed: 0.1, loop: true, autoPlay: true }, "walk": { frames: "1-3", speed: 0.18, loop: true, autoPlay: false }, "jump": { frames: "4", speed: 0.1, loop: false, autoPlay: false } });

  // === INPUT ===
  const _keys = {};
  const _justPressed = {};
  window.addEventListener('keydown', (e) => {
    if (!_keys[e.key]) _justPressed[e.key] = true;
    _keys[e.key] = true;
  });
  window.addEventListener('keyup', (e) => {
    _keys[e.key] = false;
  });
  function _clearJustPressed() {
    for (const k in _justPressed) delete _justPressed[k];
  }
  const _controlledSprites = {};
  _controlledSprites["mario"] = { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp', jump: 'ArrowUp', left2: 'a', right2: 'd', up2: 'w', jump2: 'w' };

  // === MOUSE ===
  // Mouse System
  let _mouseX = 0;
  let _mouseY = 0;
  let _mouseWorldX = 0;
  let _mouseWorldY = 0;
  app.canvas.addEventListener('pointermove', (e) => {
    const rect = app.canvas.getBoundingClientRect();
    _mouseX = e.clientX - rect.left;
    _mouseY = e.clientY - rect.top;
    // Convert to world coordinates (accounting for camera)
    _mouseWorldX = _mouseX - _cameraContainer.x;
    _mouseWorldY = _mouseY - _cameraContainer.y;
  });

  // === FUNCTIONS ===
  function onGameInit(data) {
    // Iris-in effect on level start
    game.irisIn(null, 45)
    // Restore lives and score from sessionStorage (after death respawn)
    const savedLives = sessionStorage.getItem('mario_lives')
    const savedScore = sessionStorage.getItem('mario_score')
    if (savedLives !== null) {
    lives = parseInt(savedLives)
    document.getElementById('lives-display').textContent = lives
    sessionStorage.removeItem('mario_lives')
    }
    if (savedScore !== null) {
    score = parseInt(savedScore)
    document.getElementById('score-display').textContent = score
    sessionStorage.removeItem('mario_score')
    }
    // Setup Rex AI - all walk left
    game.setRexAI('rex1', -0.5)
    game.setRexAI('rex2', -0.5)
    game.setRexAI('rex3', -0.5)
    game.setRexAI('rex4', -0.5)
    game.setRexAI('rex5', -0.5)
    game.setRexAI('rex6', -0.5)
    game.setRexAI('rex7', -0.5)
    game.setRexAI('rex8', -0.5)
    game.setRexAI('rex9', -0.5)
    game.setRexAI('rex10', -0.5)
    game.setRexAI('rex11', -0.5)
    game.setRexAI('rex12', -0.5)
    // Handle music autoplay - try to play, if blocked wait for interaction
    const tryPlayMusic = () => {
    game.playSound('bgm-level', { loop: true, volume: 0.5 })
    }
    // Browser autoplay requires user gesture - add click handler
    const startMusic = () => {
    tryPlayMusic()
    document.removeEventListener('click', startMusic)
    document.removeEventListener('keydown', startMusic)
    }
    document.addEventListener('click', startMusic, { once: true })
    document.addEventListener('keydown', startMusic, { once: true })
  }

  function onCoinCollected(data) {
    coins = coins + 1
    score = score + 10
    document.getElementById('coin-display').textContent = coins
    document.getElementById('score-display').textContent = score
  }

  function onBlockHit(data) {
    if (!data || !data.other) return
    if (data.other._blockUsed) return
    game.hitBlock(data.other, 'assets/smw/sprites/qblock_used.png', 'assets/smw/sprites/coin_animated.png', 16, 16)
    coins = coins + 1
    score = score + 10
    document.getElementById('coin-display').textContent = coins
    document.getElementById('score-display').textContent = score
  }

  function onEnemyCollision(data) {
    if (!data || !data.other) return
    if (isDead) return
    const mario = _sprites['mario']
    const enemy = data.other
    if (!mario || !enemy || !mario.body || !enemy.body) return
    // Rex is 12x24, Mario is 16x24
    // Body positions are at center
    const marioFeet = mario.body.position.y + 12
    const rexHead = enemy.body.position.y - (enemy._rexSquished ? 6 : 12)
    const marioVelY = mario.body.velocity.y
    // Stomp: Mario's feet must be above Rex's head AND Mario must be falling
    // More strict check: feet must be clearly above head (not just touching)
    const isAbove = marioFeet < rexHead + 4
    const isFalling = marioVelY > 0.5
    if (isAbove && isFalling) {
    // Stomp! Emit sound event
    _gameEvents.emit('enemy-stomped', { enemy: enemy.id })
    // Check if Rex already squished
    if (enemy._rexSquished) {
    // Second stomp - kill Rex
    game.destroySprite(enemy.id)
    score = score + 200
    } else {
    // First stomp - squish Rex (makes it shorter and faster)
    enemy._rexSquished = true
    enemy.sprite.scale.y = 0.5
    enemy._rexSpeed = (enemy._rexSpeed || 0.4) * 1.5
    score = score + 100
    }
    // Bounce Mario up
    Matter.Body.setVelocity(mario.body, { x: mario.body.velocity.x, y: -6 })
    document.getElementById('score-display').textContent = score
    } else {
    // Side collision - Mario dies!
    isDead = 1
    lives = lives - 1
    document.getElementById('lives-display').textContent = lives
    _gameEvents.emit('mario-died', {})
    game.killPlayer('mario')
    }
  }

  function onFellInPit(data) {
    if (isDead) return
    isDead = 1
    lives = lives - 1
    document.getElementById('lives-display').textContent = lives
    _gameEvents.emit('mario-died', {})
    game.killPlayer('mario')
  }

  function onDeathAnimationComplete(data) {
    // Iris-out effect before transition
    game.irisOut(function() {
    if (lives <= 0) {
    // Game Over
    document.getElementById('gameover-score').textContent = score
    document.getElementById('game-over').style.display = 'block'
    } else {
    // Reload entire level (enemies, blocks, everything back to initial state)
    // Store lives in sessionStorage to preserve across reload
    sessionStorage.setItem('mario_lives', lives)
    sessionStorage.setItem('mario_score', score)
    location.reload()
    }
    }, 30)
  }

  function onLevelComplete(data) {
    // Stop background music
    game.stopSound('bgm-level')
    game.pause()
    score = score + 1000
    // Iris-out effect then show level complete
    game.irisOut(function() {
    document.getElementById('final-score').textContent = score
    document.getElementById('level-complete').style.display = 'block'
    }, 45)
  }


  // === COLLISIONS ===
  Matter.Events.on(mEngine, 'collisionStart', (event) => {
    for (const pair of event.pairs) {
      const a = _bodyToSprite[pair.bodyA.id];
      const b = _bodyToSprite[pair.bodyB.id];
      if (a && b) {
        _handleCollision(a, b);
        _handleCollision(b, a);
      }
    }
  });

  function _handleCollision(selfId, otherId) {
    const selfInfo = _sprites[selfId];
    const otherInfo = _sprites[otherId];
    if (!selfInfo || !otherInfo) {
      return;
    }
    if (selfInfo.collisionHandlers) {
      for (const handler of selfInfo.collisionHandlers) {
        handler(selfInfo, otherInfo);
      }
    }
  }

  // === SOUNDS ===
  // Audio System
  const _sounds = {};
  let _audioCtx = null;
  let _audioUnlocked = false;
  const _pendingSounds = [];

  function _initAudio() {
    if (_audioCtx) {
      return;
    }
    _audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Unlock audio on any user interaction
    const unlockEvents = ['click', 'keydown', 'touchstart', 'pointerdown'];
    function _unlock() {
      if (_audioUnlocked) {
        return;
      }
      if (_audioCtx.state === 'suspended') {
        _audioCtx.resume().then(() => {
          _audioUnlocked = true;
          // Play any queued sounds
          while (_pendingSounds.length > 0) {
            const pending = _pendingSounds.shift();
            const _psrc = _doPlaySound(pending.id, pending.opts);
            if (_psrc) {
              _activeSources[pending.id] = _psrc;
              _psrc.onended = function() { if (_activeSources[pending.id] === _psrc) delete _activeSources[pending.id]; };
            }
          }
        });
      } else {
        _audioUnlocked = true;
      }
      for (const evt of unlockEvents) {
        document.removeEventListener(evt, _unlock);
      }
    }

    for (const evt of unlockEvents) {
      document.addEventListener(evt, _unlock, { once: false });
    }
  }

  async function _loadSound(id, url) {
    _initAudio();
    try {
      const resp = await fetch(url);
      const buf = await resp.arrayBuffer();
      _sounds[id] = await _audioCtx.decodeAudioData(buf);
    }
    catch(e) {
      console.warn('Sound load failed:', id, e);
    }
  }

  function _doPlaySound(id, opts) {
    opts = opts || {};
    const buf = _sounds[id];
    if (!buf) {
      return;
    }
    const src = _audioCtx.createBufferSource();
    src.buffer = buf;
    const gain = _audioCtx.createGain();
    gain.gain.value = opts.volume !== undefined ? opts.volume : 1;
    src.connect(gain).connect(_audioCtx.destination);
    src.loop = !!opts.loop;
    src.start(0);
    return src;
  }

  const _activeSources = {};

  function _playSound(id, opts) {
    if (!_audioUnlocked) {
      _pendingSounds.push({ id: id, opts: opts });
      return;
    }
    const src = _doPlaySound(id, opts);
    if (src) {
      _activeSources[id] = src;
      src.onended = function() { if (_activeSources[id] === src) delete _activeSources[id]; };
    }
    return src;
  }

  function _stopSound(id) {
    const src = _activeSources[id];
    if (src) {
      try {
        src.stop();
      }
      catch(e) {
      }
      delete _activeSources[id];
    }
  }
  await _loadSound("sfx-jump", "assets/smw/sounds/smw_jump.wav");
  await _loadSound("sfx-coin", "assets/smw/sounds/smw_coin.wav");
  await _loadSound("sfx-stomp", "assets/smw/sounds/smw_stomp.wav");
  await _loadSound("sfx-death", "assets/smw/sounds/smw_lost_a_life.wav");
  await _loadSound("sfx-clear", "assets/smw/sounds/smw_course_clear.wav");
  await _loadSound("sfx-block", "assets/smw/sounds/smw_message_block.wav");
  await _loadSound("bgm-level", "assets/smw/sounds/music/music-map1.wav");

  // === PARTICLES ===
  // Particle System
  const _particleSystems = {};

  function _createParticleSystem(config) {
    const ps = {
      id: config.id,
      follow: config.follow || null,
      trigger: config.trigger || null,
      count: config.count || 20,
      emitRate: config.emitRate || 10,
      lifetime: config.lifetime || 1,
      speedMin: config.speedMin || 1,
      speedMax: config.speedMax || 3,
      angleMin: (config.angleMin || 0) * Math.PI / 180,
      angleMax: (config.angleMax || 360) * Math.PI / 180,
      alphaStart: config.alphaStart !== undefined ? config.alphaStart : 1,
      alphaEnd: config.alphaEnd !== undefined ? config.alphaEnd : 0,
      active: false,
      emitTimer: 0,
      pool: [],
      container: new PIXI.Container(),
    };

    // Pre-allocate particle pool
    for (let i = 0; i <= ps.count - 1; i += 1) {
      const p = new PIXI.Graphics();
      p.circle(0, 0, 3);
      p.fill({ color: 0xffffff });
      p.visible = false;
      p._life = 0; p._maxLife = 0; p._vx = 0; p._vy = 0;
      p._alphaStart = 1; p._alphaEnd = 0;
      ps.container.addChild(p);
      ps.pool.push(p);
    }

    _cameraContainer.addChild(ps.container);
    _particleSystems[config.id] = ps;
    return ps;
  }

  function _emitParticle(ps, x, y) {
    for (const p of ps.pool) {
      if (!p.visible) {
        p.x = x;
        p.y = y;
        const angle = ps.angleMin + Math.random() * (ps.angleMax - ps.angleMin);
        const speed = ps.speedMin + Math.random() * (ps.speedMax - ps.speedMin);
        p._vx = Math.cos(angle) * speed;
        p._vy = Math.sin(angle) * speed;
        p._life = 0;
        p._maxLife = ps.lifetime;
        p._alphaStart = ps.alphaStart;
        p._alphaEnd = ps.alphaEnd;
        p.alpha = ps.alphaStart;
        p.visible = true;
        return;
      }
    }
  }

  function _activateParticles(psId) {
    const ps = _particleSystems[psId];
    if (ps) {
      ps.active = true;
    }
  }

  function _deactivateParticles(psId) {
    const ps = _particleSystems[psId];
    if (ps) {
      ps.active = false;
    }
  }

  function _updateParticles(dt) {
    for (const [id, ps] of Object.entries(_particleSystems)) {
      // Emit new particles if active
      if (ps.active) {
        ps.emitTimer += dt / 60;
        const interval = 1 / ps.emitRate;
        while (ps.emitTimer >= interval) {
          ps.emitTimer -= interval;
          let ex = 0;
          let ey = 0;
          if (ps.follow) {
            const info = _sprites[ps.follow];
            if (info) {
              ex = info.sprite.x;
              ey = info.sprite.y;
            }
          }
          _emitParticle(ps, ex, ey);
        }
      }

      // Update living particles
      for (const p of ps.pool) {
        if (!p.visible) {
          continue;
        }
        p._life += dt / 60;
        if (p._life >= p._maxLife) {
          p.visible = false;
          continue;
        }
        const lifeT = p._life / p._maxLife;
        p.x = p.x + p._vx;
        p.y = p.y + p._vy;
        p.alpha = p._alphaStart + (p._alphaEnd - p._alphaStart) * lifeT;
      }
    }
  }
  // No particle instances

  // === TIMERS ===
  // Timer System
  const _timers = {};
  const _timerActions = {};

  function _createTimer(id, interval, repeat, autoStart, actionFn) {
    _timers[id] = { elapsed: 0, interval: interval, repeat: repeat, count: 0, active: autoStart };
    _timerActions[id] = actionFn;
  }

  function _updateTimers(dt) {
    for (const [tid, t] of Object.entries(_timers)) {
      if (!t.active) {
        continue;
      }
      t.elapsed += dt / 60;
      if (t.elapsed >= t.interval) {
        t.elapsed = 0;
        if (_timerActions[tid]) {
          _timerActions[tid]();
        }
        t.count++;
        if (t.repeat >= 0 && t.count >= t.repeat) {
          t.active = false;
        }
      }
    }
  }
  // No timer instances

  // === TWEENS ===
  // Easing Functions
  const _easing = {
    linear: t => t,
    easeIn: t => t * t,
    easeOut: t => t * (2 - t),
    easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    easeInCubic: t => t * t * t,
    easeOutCubic: t => (--t) * t * t + 1,
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    easeInQuart: t => t * t * t * t,
    easeOutQuart: t => 1 - (--t) * t * t * t,
    easeInOutQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,
    easeOutBounce: t => {
      if (t < 1/2.75) return 7.5625 * t * t;
      if (t < 2/2.75) return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
      if (t < 2.5/2.75) return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
      return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
    },
    easeInBounce: t => 1 - _easing.easeOutBounce(1 - t),
    easeOutElastic: t => {
      if (t === 0 || t === 1) return t;
      return Math.pow(2, -10 * t) * Math.sin((t - 0.075) * (2 * Math.PI) / 0.3) + 1;
    },
    easeInElastic: t => {
      if (t === 0 || t === 1) return t;
      return -Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.075) * (2 * Math.PI) / 0.3);
    },
  };

  const _tweens = {};
  let _tweenIdCounter = 0;

  function _createTween(config) {
    const id = config.id || ('tween_' + _tweenIdCounter++);
    _tweens[id] = {
      target: config.target,
      prop: config.prop,
      from: null,
      to: config.to,
      duration: config.duration || 1,
      easing: config.easing || 'linear',
      loop: !!config.loop,
      yoyo: !!config.yoyo,
      delay: config.delay || 0,
      elapsed: 0,
      delayElapsed: 0,
      active: config.active !== false,
      started: false,
    };
    return id;
  }

  function _updateTweens(dt) {
    for (const [tid, tw] of Object.entries(_tweens)) {
      if (!tw.active) {
        continue;
      }
      // Handle delay
      if (tw.delayElapsed < tw.delay) {
        tw.delayElapsed += dt / 60;
        continue;
      }
      // Init start value on first frame
      if (!tw.started) {
        const info = _sprites[tw.target];
        if (!info) {
          continue;
        }
        tw.from = info.sprite[tw.prop];
        tw.started = true;
      }
      tw.elapsed += dt / 60;
      const rawT = Math.min(tw.elapsed / tw.duration, 1);
      const easeFn = _easing[tw.easing] || _easing.linear;
      const t = easeFn(rawT);
      const info = _sprites[tw.target];
      if (info) {
        info.sprite[tw.prop] = tw.from + (tw.to - tw.from) * t;
      }
      if (rawT >= 1) {
        if (tw.loop) {
          tw.elapsed = 0;
          if (tw.yoyo) {
            const tmp = tw.from;
            tw.from = tw.to;
            tw.to = tmp;
          }
        } else {
          tw.active = false;
        }
      }
    }
  }
  // No tween instances

  // === SPAWNERS ===
  // No spawners

  // === HUD UPDATE ===
  const _hudElements = [];
  _hudElements.push(document.getElementById('qg-hud-0'));
  _hudElements.push(document.getElementById('qg-hud-1'));
  _hudElements.push(document.getElementById('qg-hud-2'));
  function _updateHUD() {
  }

  // === GAME LOOP ===
  app.ticker.add((ticker) => {
    const dt = ticker.deltaTime;
    // Sub-step physics with velocity clamping to prevent tunneling
    const _fixedDt = 16.67;
    const _maxSteps = 3;
    const _maxVel = 12;
    const _steps = Math.min(Math.ceil(dt), _maxSteps);
    for (let _i = 0; _i <= _steps; _i += 1) {
      // Clamp velocities BEFORE physics step
      for (const [_sid, _sinfo] of Object.entries(_sprites)) {
        if (_sinfo.body && !_sinfo.body.isStatic) {
          const _bv = _sinfo.body.velocity;
          if (Math.abs(_bv.x) > _maxVel || Math.abs(_bv.y) > _maxVel) {
            Matter.Body.setVelocity(_sinfo.body, {
              x: Math.max(-_maxVel, Math.min(_maxVel, _bv.x)),
              y: Math.max(-_maxVel, Math.min(_maxVel, _bv.y))
            });
          }
        }
      }
      Matter.Engine.update(mEngine, _fixedDt);
    }
    syncPhysics();
    // Input handling
    const _ctrl_mario = _controlledSprites["mario"];
    // Movement with dual key support (arrows + WASD)
    const _leftPressed_mario = _keys[_ctrl_mario.left] || (_keys[_ctrl_mario.left2] || false);
    const _rightPressed_mario = _keys[_ctrl_mario.right] || (_keys[_ctrl_mario.right2] || false);
    const _jumpPressed_mario = _keys[_ctrl_mario.jump] || (_keys[_ctrl_mario.jump2] || false);
    const _jumpJust_mario = _justPressed[_ctrl_mario.jump] || (_justPressed[_ctrl_mario.jump2] || false);
    if (_leftPressed_mario && _sprites["mario"].body) {
      Matter.Body.setVelocity(_sprites["mario"].body, { x: -2, y: _sprites["mario"].body.velocity.y });
      _sprites["mario"].sprite.scale.x = Math.abs(_sprites["mario"].sprite.scale.x);
    }
    if (_rightPressed_mario && _sprites["mario"].body) {
      Matter.Body.setVelocity(_sprites["mario"].body, { x: 2, y: _sprites["mario"].body.velocity.y });
      _sprites["mario"].sprite.scale.x = -Math.abs(_sprites["mario"].sprite.scale.x);
    }
    // SMW-style jump: coyote time, variable height, asymmetric gravity
    if (_sprites["mario"]._coyoteFrames === undefined) {
      _sprites["mario"]._coyoteFrames = 0;
      _sprites["mario"]._jumpHeld = false;
      _sprites["mario"]._wasGrounded = false;
    }
    const _isGrounded_mario = _sprites["mario"].body && Math.abs(_sprites["mario"].body.velocity.y) < 1.0;
    if (_isGrounded_mario) {
      _sprites["mario"]._coyoteFrames = 6;
      _sprites["mario"]._wasGrounded = true;
    } else if (_sprites["mario"]._coyoteFrames > 0) {
      _sprites["mario"]._coyoteFrames--;
    }
    const _canJump_mario = _isGrounded_mario || _sprites["mario"]._coyoteFrames > 0;
    if (_jumpJust_mario && _sprites["mario"].body && _canJump_mario) {
      Matter.Body.setVelocity(_sprites["mario"].body, { x: _sprites["mario"].body.velocity.x, y: -5.5 });
      _sprites["mario"]._jumpHeld = true;
      _sprites["mario"]._coyoteFrames = 0;
      _gameEvents.emit('player.jump', _sprites["mario"]);
    }
    if (_jumpPressed_mario && _sprites["mario"].body && _sprites["mario"]._jumpHeld && _sprites["mario"].body.velocity.y < 0) {
      Matter.Body.setVelocity(_sprites["mario"].body, { x: _sprites["mario"].body.velocity.x, y: _sprites["mario"].body.velocity.y - 0.4 });
    }
    if (!_jumpPressed_mario) {
      _sprites["mario"]._jumpHeld = false;
    }
    if (_sprites["mario"].body && _sprites["mario"].body.velocity.y > 15) {
      Matter.Body.setVelocity(_sprites["mario"].body, { x: _sprites["mario"].body.velocity.x, y: 15 });
    }
    if (!_leftPressed_mario && !_rightPressed_mario && _sprites["mario"].body) {
      Matter.Body.setVelocity(_sprites["mario"].body, { x: 0, y: _sprites["mario"].body.velocity.y });
      _gameEvents.emit('player.stop', _sprites["mario"]);
    } else {
      _gameEvents.emit('player.walk', _sprites["mario"]);
    }
    _clearJustPressed();
    updateCamera();
    _updateControlAnimations();
    _updateAnimatedSprites(ticker);
    // Behaviors update
    for (const [_id, _info] of Object.entries(_sprites)) {
      if (_info.behaviors) {
        for (const b of _info.behaviors) {
          if (b._smUpdate) {
            b._smUpdate();
          }
          if (b.update) {
            b.update();
          }
        }
      }
    }
    _updateHUD();
  });

  // === SCENE START ===
  // qg:event handlers
  _gameEvents.on("coin-collected", (data) => {
    if (typeof onCoinCollected === 'function') {
      onCoinCollected(data);
    }
  });
  _gameEvents.on("block-hit", (data) => {
    if (typeof onBlockHit === 'function') {
      onBlockHit(data);
    }
  });
  _gameEvents.on("enemy-collision", (data) => {
    if (typeof onEnemyCollision === 'function') {
      onEnemyCollision(data);
    }
  });
  _gameEvents.on("fell-in-pit", (data) => {
    if (typeof onFellInPit === 'function') {
      onFellInPit(data);
    }
  });
  _gameEvents.on("death-animation-complete", (data) => {
    if (typeof onDeathAnimationComplete === 'function') {
      onDeathAnimationComplete(data);
    }
  });
  _gameEvents.on("level-complete", (data) => {
    if (typeof onLevelComplete === 'function') {
      onLevelComplete(data);
    }
  });
  _gameEvents.on("game-init", (data) => {
    if (typeof onGameInit === 'function') {
      onGameInit(data);
    }
  });
  _gameEvents.on("player.jump", () => _playSound("sfx-jump", { volume: 1, loop: false }));
  _gameEvents.on("coin-collected", () => _playSound("sfx-coin", { volume: 1, loop: false }));
  _gameEvents.on("enemy-stomped", () => _playSound("sfx-stomp", { volume: 1, loop: false }));
  _gameEvents.on("mario-died", () => _playSound("sfx-death", { volume: 1, loop: false }));
  _gameEvents.on("level-complete", () => _playSound("sfx-clear", { volume: 1, loop: false }));
  _gameEvents.on("block-hit", () => _playSound("sfx-block", { volume: 1, loop: false }));
  _playSound("bgm-level", { volume: 0.5, loop: true });
  _gameEvents.emit('game-init', {});
})();
  </script>
</body>
</html>
